{"mappings":"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","sources":["node_modules/pathfinding/src/PathFinding.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","node_modules/pathfinding/src/core/Grid.js","node_modules/pathfinding/src/core/DiagonalMovement.js","node_modules/pathfinding/src/core/Util.js","node_modules/pathfinding/src/core/Heuristic.js","node_modules/pathfinding/src/finders/AStarFinder.js","node_modules/pathfinding/src/finders/BestFirstFinder.js","node_modules/pathfinding/src/finders/BreadthFirstFinder.js","node_modules/pathfinding/src/finders/DijkstraFinder.js","node_modules/pathfinding/src/finders/BiAStarFinder.js","node_modules/pathfinding/src/finders/BiBestFirstFinder.js","node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js","node_modules/pathfinding/src/finders/BiDijkstraFinder.js","node_modules/pathfinding/src/finders/IDAStarFinder.js","node_modules/pathfinding/src/finders/JumpPointFinder.js","node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js","node_modules/pathfinding/src/finders/JumpPointFinderBase.js","node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js","node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js","node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js","node_modules/immer/src/utils/errors.ts","node_modules/immer/src/utils/common.ts","node_modules/immer/src/utils/plugins.ts","node_modules/immer/src/core/scope.ts","node_modules/immer/src/core/finalize.ts","node_modules/immer/src/core/proxy.ts","node_modules/immer/src/core/immerClass.ts","node_modules/immer/src/core/current.ts","node_modules/immer/src/plugins/es5.ts","node_modules/immer/src/immer.ts","node_modules/immer/src/utils/env.ts","node_modules/@babel/runtime/helpers/esm/defineProperty.js","node_modules/@babel/runtime/helpers/esm/objectSpread2.js","node_modules/redux/es/redux.js","node_modules/redux-thunk/es/index.js","node_modules/@reduxjs/toolkit/src/devtoolsExtension.ts","node_modules/@reduxjs/toolkit/src/isPlainObject.ts","node_modules/@reduxjs/toolkit/src/utils.ts","node_modules/@reduxjs/toolkit/src/getDefaultMiddleware.ts","node_modules/@reduxjs/toolkit/src/configureStore.ts","node_modules/@reduxjs/toolkit/src/createAction.ts","node_modules/@reduxjs/toolkit/src/mapBuilders.ts","node_modules/@reduxjs/toolkit/src/createSlice.ts","node_modules/@reduxjs/toolkit/src/createReducer.ts","node_modules/@reduxjs/toolkit/src/listenerMiddleware/index.ts","node_modules/@reduxjs/toolkit/src/index.ts","node_modules/javascript-astar/astar.js","node_modules/hexagrid/src/utils.ts","node_modules/hexagrid/src/hex.ts","node_modules/hexagrid/index.ts","node_modules/hexagrid/src/direction.ts","node_modules/hexagrid/src/cubecoordinates.ts","node_modules/hexagrid/src/grid.ts","node_modules/honeycomb-grid/node_modules/axis.js/dist/axis.js","node_modules/honeycomb-grid/src/utils.js","node_modules/honeycomb-grid/src/hex/constants.js","node_modules/honeycomb-grid/src/grid/prototype.js","node_modules/honeycomb-grid/src/grid/statics.js","node_modules/honeycomb-grid/src/point/prototype.js","node_modules/honeycomb-grid/src/point/index.js","node_modules/honeycomb-grid/src/grid/class.js","node_modules/honeycomb-grid/src/hex/prototype.js","node_modules/honeycomb-grid/src/hex/index.js","node_modules/honeycomb-grid/src/hex/statics.js","node_modules/honeycomb-grid/src/honeycomb.js","src/modules/lib/utilities.js","node_modules/honeycomb-grid/src/grid/index.js","src/modules/lib/hexagons.js","src/modules/lib/map.js","node_modules/pathfinding/index.js","src/modules/state/slices/gameSlice.js","src/modules/lib/pathFinding.js","src/modules/state/store.js","src/modules/lib/canvasUtilites.js","src/index.js","src/modules/components/Map.js","src/modules/components/Enemy.js","src/modules/components/Player.js"],"sourcesContent":["module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n","var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // \r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // \r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // \r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // \r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // \r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n","var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;","/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n","/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n","var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n","/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\n\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\treturn result.then(nextState => [nextState, patches!, inversePatches!])\n\t\t}\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyType,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyType.ES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyType.ES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (!draft_.hasOwnProperty(i)) {\n\t\t\t\t\tassigned_[i] = true\n\t\t\t\t}\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\t// last descriptor can be not a trap, if the array was extended\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// if we miss a property, it has been deleted, so array probobaly changed\n\t\tfor (let i = 0; i < draft_.length; i++) {\n\t\t\tif (!draft_.hasOwnProperty(i)) return true\n\t\t}\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyType.ES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */\nfunction formatProdErrorMessage(code) {\n  return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + 'use the non-minified dev environment for full errors. ';\n}\n\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = (function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n})();\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'symbol':\n    case 'function':\n      {\n        return type;\n      }\n  }\n\n  if (Array.isArray(val)) return 'array';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  var constructorName = ctorName(val);\n\n  switch (constructorName) {\n    case 'Symbol':\n    case 'Promise':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Map':\n    case 'Set':\n      return constructorName;\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n}\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction kindOf(val) {\n  var typeOfVal = typeof val;\n\n  if (process.env.NODE_ENV !== 'production') {\n    typeOfVal = miniKindOf(val);\n  }\n\n  return typeOfVal;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(0) : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(1) : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(2) : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(3) : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(4) : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(5) : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(6) : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(7) : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(8) : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(9) : 'Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(10) : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(11) : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return \"The \" + argumentName + \" has unexpected type of \\\"\" + kindOf(inputState) + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(12) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(13) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle '\" + ActionTypes.INIT + \"' or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(\"No reducer provided for key \\\"\" + key + \"\\\"\");\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n  // keys multiple times.\n\n  var unexpectedKeyCache;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var actionType = action && action.type;\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(14) : \"When called with an action of type \" + (actionType ? \"\\\"\" + String(actionType) + \"\\\"\" : '(unknown type)') + \", the slice reducer for key \\\"\" + _key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(16) : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + \"Did you write \\\"import ActionCreators from\\\" instead of \\\"import * as ActionCreators from\\\"?\");\n  }\n\n  var boundActionCreators = {};\n\n  for (var key in actionCreators) {\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(15) : 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread(_objectSpread({}, store), {}, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { ActionTypes as __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore };\n","/** A function that accepts a potential \"extra argument\" value to be injected later,\r\n * and returns an instance of the thunk middleware that uses that value\r\n */\nfunction createThunkMiddleware(extraArgument) {\n  // Standard Redux middleware definition pattern:\n  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware\n  var middleware = function middleware(_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        // The thunk middleware looks for any functions that were passed to `store.dispatch`.\n        // If this \"action\" is really a function, call it and return the result.\n        if (typeof action === 'function') {\n          // Inject the store's `dispatch` and `getState` methods, as well as any \"extra arg\"\n          return action(dispatch, getState, extraArgument);\n        } // Otherwise, pass the action down the middleware chain as usual\n\n\n        return next(action);\n      };\n    };\n  };\n\n  return middleware;\n}\n\nvar thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version\n// with whatever \"extra arg\" they want to inject into their thunks\n\nthunk.withExtraArgument = createThunkMiddleware;\nexport default thunk;","import type { Action, ActionCreator, StoreEnhancer } from 'redux'\r\nimport { compose } from 'redux'\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface EnhancerOptions {\r\n  /**\r\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\r\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\r\n   */\r\n  name?: string\r\n  /**\r\n   * action creators functions to be available in the Dispatcher.\r\n   */\r\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\r\n  /**\r\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\r\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\r\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\r\n   *\r\n   * @default 500 ms.\r\n   */\r\n  latency?: number\r\n  /**\r\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\r\n   *\r\n   * @default 50\r\n   */\r\n  maxAge?: number\r\n  /**\r\n   * See detailed documentation at https://github.com/reduxjs/redux-devtools/blob/%40redux-devtools/extension%403.2.1/extension/docs/API/Arguments.md#serialize\r\n   */\r\n  serialize?:\r\n    | boolean\r\n    | {\r\n        options?:\r\n          | boolean\r\n          | {\r\n              date?: boolean\r\n              regex?: boolean\r\n              undefined?: boolean\r\n              error?: boolean\r\n              symbol?: boolean\r\n              map?: boolean\r\n              set?: boolean\r\n              function?: boolean | Function\r\n            }\r\n        replacer?: (key: string, value: unknown) => unknown\r\n        reviver?: (key: string, value: unknown) => unknown\r\n        immutable?: unknown\r\n        refs?: unknown[]\r\n      }\r\n  /**\r\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\r\n   */\r\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\r\n  /**\r\n   * function which takes `state` object and index as arguments, and should return `state` object back.\r\n   */\r\n  stateSanitizer?: <S>(state: S, index: number) => S\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsBlacklist?: string | string[]\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsWhitelist?: string | string[]\r\n  /**\r\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\r\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\r\n   */\r\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\r\n  /**\r\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\r\n   * Available only for Redux enhancer, for others use `autoPause`.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldRecordChanges?: boolean\r\n  /**\r\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\r\n   * If not specified, will commit when paused. Available only for Redux enhancer.\r\n   *\r\n   * @default \"@@PAUSED\"\"\r\n   */\r\n  pauseActionType?: string\r\n  /**\r\n   * auto pauses when the extensions window is not opened, and so has zero impact on your app when not in use.\r\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\r\n   *\r\n   * @default false\r\n   */\r\n  autoPause?: boolean\r\n  /**\r\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\r\n   * Available only for Redux enhancer.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldStartLocked?: boolean\r\n  /**\r\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldHotReload?: boolean\r\n  /**\r\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldCatchErrors?: boolean\r\n  /**\r\n   * If you want to restrict the extension, specify the features you allow.\r\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\r\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\r\n   * Otherwise, you'll get/set the data right from the monitor part.\r\n   */\r\n  features?: {\r\n    /**\r\n     * start/pause recording of dispatched actions\r\n     */\r\n    pause?: boolean\r\n    /**\r\n     * lock/unlock dispatching actions and side effects\r\n     */\r\n    lock?: boolean\r\n    /**\r\n     * persist states on page reloading\r\n     */\r\n    persist?: boolean\r\n    /**\r\n     * export history of actions in a file\r\n     */\r\n    export?: boolean | 'custom'\r\n    /**\r\n     * import history of actions from a file\r\n     */\r\n    import?: boolean | 'custom'\r\n    /**\r\n     * jump back and forth (time travelling)\r\n     */\r\n    jump?: boolean\r\n    /**\r\n     * skip (cancel) actions\r\n     */\r\n    skip?: boolean\r\n    /**\r\n     * drag and drop actions in the history list\r\n     */\r\n    reorder?: boolean\r\n    /**\r\n     * dispatch custom actions or action creators\r\n     */\r\n    dispatch?: boolean\r\n    /**\r\n     * generate tests for the selected actions\r\n     */\r\n    test?: boolean\r\n  }\r\n  /**\r\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\r\n   * Defaults to false.\r\n   */\r\n  trace?: boolean | (<A extends Action>(action: A) => string)\r\n  /**\r\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\r\n   */\r\n  traceLimit?: number\r\n}\r\n\r\ntype Compose = typeof compose\r\n\r\ninterface ComposeWithDevTools {\r\n  (options: EnhancerOptions): Compose\r\n  <StoreExt>(...funcs: StoreEnhancer<StoreExt>[]): StoreEnhancer<StoreExt>\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const composeWithDevTools: ComposeWithDevTools =\r\n  typeof window !== 'undefined' &&\r\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    : function () {\r\n        if (arguments.length === 0) return undefined\r\n        if (typeof arguments[0] === 'object') return compose\r\n        return compose.apply(null, arguments as any as Function[])\r\n      }\r\n\r\n/**\r\n * @public\r\n */\r\nexport const devToolsEnhancer: {\r\n  (options: EnhancerOptions): StoreEnhancer<any>\r\n} =\r\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    : function () {\r\n        return function (noop) {\r\n          return noop\r\n        }\r\n      }\r\n","/**\r\n * Returns true if the passed value is \"plain\" object, i.e. an object whose\r\n * prototype is the root `Object.prototype`. This includes objects created\r\n * using object literals, but not for instance for class instances.\r\n *\r\n * @param {any} value The value to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n *\r\n * @public\r\n */\r\nexport default function isPlainObject(value: unknown): value is object {\r\n  if (typeof value !== 'object' || value === null) return false\r\n\r\n  let proto = Object.getPrototypeOf(value)\r\n  if (proto === null) return true\r\n\r\n  let baseProto = proto\r\n  while (Object.getPrototypeOf(baseProto) !== null) {\r\n    baseProto = Object.getPrototypeOf(baseProto)\r\n  }\r\n\r\n  return proto === baseProto\r\n}\r\n","import type { Middleware } from 'redux'\r\n\r\nexport function getTimeMeasureUtils(maxDelay: number, fnName: string) {\r\n  let elapsed = 0\r\n  return {\r\n    measureTime<T>(fn: () => T): T {\r\n      const started = Date.now()\r\n      try {\r\n        return fn()\r\n      } finally {\r\n        const finished = Date.now()\r\n        elapsed += finished - started\r\n      }\r\n    },\r\n    warnIfExceeded() {\r\n      if (elapsed > maxDelay) {\r\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \r\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\r\nIt is disabled in production builds, so you don't need to worry about that.`)\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MiddlewareArray<\r\n  Middlewares extends Middleware<any, any>[]\r\n> extends Array<Middlewares[number]> {\r\n  constructor(...items: Middlewares)\r\n  constructor(...args: any[]) {\r\n    super(...args)\r\n    Object.setPrototypeOf(this, MiddlewareArray.prototype)\r\n  }\r\n\r\n  static get [Symbol.species]() {\r\n    return MiddlewareArray as any\r\n  }\r\n\r\n  concat<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(\r\n    items: AdditionalMiddlewares\r\n  ): MiddlewareArray<[...Middlewares, ...AdditionalMiddlewares]>\r\n\r\n  concat<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(\r\n    ...items: AdditionalMiddlewares\r\n  ): MiddlewareArray<[...Middlewares, ...AdditionalMiddlewares]>\r\n  concat(...arr: any[]) {\r\n    return super.concat.apply(this, arr)\r\n  }\r\n\r\n  prepend<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(\r\n    items: AdditionalMiddlewares\r\n  ): MiddlewareArray<[...AdditionalMiddlewares, ...Middlewares]>\r\n\r\n  prepend<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(\r\n    ...items: AdditionalMiddlewares\r\n  ): MiddlewareArray<[...AdditionalMiddlewares, ...Middlewares]>\r\n\r\n  prepend(...arr: any[]) {\r\n    if (arr.length === 1 && Array.isArray(arr[0])) {\r\n      return new MiddlewareArray(...arr[0].concat(this))\r\n    }\r\n    return new MiddlewareArray(...arr.concat(this))\r\n  }\r\n}\r\n","import type { Middleware, AnyAction } from 'redux'\r\nimport type { ThunkMiddleware } from 'redux-thunk'\r\nimport thunkMiddleware from 'redux-thunk'\r\nimport type { ImmutableStateInvariantMiddlewareOptions } from './immutableStateInvariantMiddleware'\r\n/* PROD_START_REMOVE_UMD */\r\nimport { createImmutableStateInvariantMiddleware } from './immutableStateInvariantMiddleware'\r\n/* PROD_STOP_REMOVE_UMD */\r\n\r\nimport type { SerializableStateInvariantMiddlewareOptions } from './serializableStateInvariantMiddleware'\r\nimport { createSerializableStateInvariantMiddleware } from './serializableStateInvariantMiddleware'\r\nimport type { ExcludeFromTuple } from './tsHelpers'\r\nimport { MiddlewareArray } from './utils'\r\n\r\nfunction isBoolean(x: any): x is boolean {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\ninterface ThunkOptions<E = any> {\r\n  extraArgument: E\r\n}\r\n\r\ninterface GetDefaultMiddlewareOptions {\r\n  thunk?: boolean | ThunkOptions\r\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\r\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\r\n}\r\n\r\nexport type ThunkMiddlewareFor<\r\n  S,\r\n  O extends GetDefaultMiddlewareOptions = {}\r\n> = O extends {\r\n  thunk: false\r\n}\r\n  ? never\r\n  : O extends { thunk: { extraArgument: infer E } }\r\n  ? ThunkMiddleware<S, AnyAction, E>\r\n  : ThunkMiddleware<S, AnyAction>\r\n\r\nexport type CurriedGetDefaultMiddleware<S = any> = <\r\n  O extends Partial<GetDefaultMiddlewareOptions> = {\r\n    thunk: true\r\n    immutableCheck: true\r\n    serializableCheck: true\r\n  }\r\n>(\r\n  options?: O\r\n) => MiddlewareArray<ExcludeFromTuple<[ThunkMiddlewareFor<S, O>], never>>\r\n\r\nexport function curryGetDefaultMiddleware<\r\n  S = any\r\n>(): CurriedGetDefaultMiddleware<S> {\r\n  return function curriedGetDefaultMiddleware(options) {\r\n    return getDefaultMiddleware(options)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns any array containing the default middleware installed by\r\n * `configureStore()`. Useful if you want to configure your store with a custom\r\n * `middleware` array but still keep the default set.\r\n *\r\n * @return The default middleware used by `configureStore()`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Prefer to use the callback notation for the `middleware` option in `configureStore`\r\n * to access a pre-typed `getDefaultMiddleware` instead.\r\n */\r\nexport function getDefaultMiddleware<\r\n  S = any,\r\n  O extends Partial<GetDefaultMiddlewareOptions> = {\r\n    thunk: true\r\n    immutableCheck: true\r\n    serializableCheck: true\r\n  }\r\n>(\r\n  options: O = {} as O\r\n): MiddlewareArray<ExcludeFromTuple<[ThunkMiddlewareFor<S, O>], never>> {\r\n  const {\r\n    thunk = true,\r\n    immutableCheck = true,\r\n    serializableCheck = true,\r\n  } = options\r\n\r\n  let middlewareArray = new MiddlewareArray<Middleware[]>()\r\n\r\n  if (thunk) {\r\n    if (isBoolean(thunk)) {\r\n      middlewareArray.push(thunkMiddleware)\r\n    } else {\r\n      middlewareArray.push(\r\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\r\n      )\r\n    }\r\n  }\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (immutableCheck) {\r\n      /* PROD_START_REMOVE_UMD */\r\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\r\n\r\n      if (!isBoolean(immutableCheck)) {\r\n        immutableOptions = immutableCheck\r\n      }\r\n\r\n      middlewareArray.unshift(\r\n        createImmutableStateInvariantMiddleware(immutableOptions)\r\n      )\r\n      /* PROD_STOP_REMOVE_UMD */\r\n    }\r\n\r\n    if (serializableCheck) {\r\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\r\n\r\n      if (!isBoolean(serializableCheck)) {\r\n        serializableOptions = serializableCheck\r\n      }\r\n\r\n      middlewareArray.push(\r\n        createSerializableStateInvariantMiddleware(serializableOptions)\r\n      )\r\n    }\r\n  }\r\n\r\n  return middlewareArray as any\r\n}\r\n","import type {\r\n  Reducer,\r\n  ReducersMapObject,\r\n  Middleware,\r\n  Action,\r\n  AnyAction,\r\n  StoreEnhancer,\r\n  Store,\r\n  Dispatch,\r\n  PreloadedState,\r\n  CombinedState,\r\n} from 'redux'\r\nimport { createStore, compose, applyMiddleware, combineReducers } from 'redux'\r\nimport type { EnhancerOptions as DevToolsOptions } from './devtoolsExtension'\r\nimport { composeWithDevTools } from './devtoolsExtension'\r\n\r\nimport isPlainObject from './isPlainObject'\r\nimport type {\r\n  ThunkMiddlewareFor,\r\n  CurriedGetDefaultMiddleware,\r\n} from './getDefaultMiddleware'\r\nimport { curryGetDefaultMiddleware } from './getDefaultMiddleware'\r\nimport type { NoInfer, ExtractDispatchExtensions } from './tsHelpers'\r\n\r\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\r\n\r\n/**\r\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\r\n *\r\n * @public\r\n */\r\nexport type ConfigureEnhancersCallback = (\r\n  defaultEnhancers: readonly StoreEnhancer[]\r\n) => StoreEnhancer[]\r\n\r\n/**\r\n * Options for `configureStore()`.\r\n *\r\n * @public\r\n */\r\nexport interface ConfigureStoreOptions<\r\n  S = any,\r\n  A extends Action = AnyAction,\r\n  M extends Middlewares<S> = Middlewares<S>\r\n> {\r\n  /**\r\n   * A single reducer function that will be used as the root reducer, or an\r\n   * object of slice reducers that will be passed to `combineReducers()`.\r\n   */\r\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\r\n\r\n  /**\r\n   * An array of Redux middleware to install. If not supplied, defaults to\r\n   * the set of middleware returned by `getDefaultMiddleware()`.\r\n   */\r\n  middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M\r\n\r\n  /**\r\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\r\n   *\r\n   * Additional configuration can be done by passing Redux DevTools options\r\n   */\r\n  devTools?: boolean | DevToolsOptions\r\n\r\n  /**\r\n   * The initial state, same as Redux's createStore.\r\n   * You may optionally specify it to hydrate the state\r\n   * from the server in universal apps, or to restore a previously serialized\r\n   * user session. If you use `combineReducers()` to produce the root reducer\r\n   * function (either directly or indirectly by passing an object as `reducer`),\r\n   * this must be an object with the same shape as the reducer map keys.\r\n   */\r\n  /* \r\n  Not 100% correct but the best approximation we can get:\r\n  - if S is a `CombinedState` applying a second `CombinedState` on it does not change anything.\r\n  - if it is not, there could be two cases:\r\n    - `ReducersMapObject<S, A>` is being passed in. In this case, we will call `combineReducers` on it and `CombinedState<S>` is correct\r\n    - `Reducer<S, A>` is being passed in. In this case, actually `CombinedState<S>` is wrong and `S` would be correct.\r\n    As we cannot distinguish between those two cases without adding another generic paramter, \r\n    we just make the pragmatic assumption that the latter almost never happens.\r\n  */\r\n  preloadedState?: PreloadedState<CombinedState<NoInfer<S>>>\r\n\r\n  /**\r\n   * The store enhancers to apply. See Redux's `createStore()`.\r\n   * All enhancers will be included before the DevTools Extension enhancer.\r\n   * If you need to customize the order of enhancers, supply a callback\r\n   * function that will receive the original array (ie, `[applyMiddleware]`),\r\n   * and should return a new array (such as `[applyMiddleware, offline]`).\r\n   * If you only need to add middleware, you can use the `middleware` parameter instead.\r\n   */\r\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\r\n}\r\n\r\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\r\n\r\n/**\r\n * A Redux store returned by `configureStore()`. Supports dispatching\r\n * side-effectful _thunks_ in addition to plain actions.\r\n *\r\n * @public\r\n */\r\nexport interface EnhancedStore<\r\n  S = any,\r\n  A extends Action = AnyAction,\r\n  M extends Middlewares<S> = Middlewares<S>\r\n> extends Store<S, A> {\r\n  /**\r\n   * The `dispatch` method of your store, enhanced by all its middlewares.\r\n   *\r\n   * @inheritdoc\r\n   */\r\n  dispatch: ExtractDispatchExtensions<M> & Dispatch<A>\r\n}\r\n\r\n/**\r\n * A friendly abstraction over the standard Redux `createStore()` function.\r\n *\r\n * @param config The store configuration.\r\n * @returns A configured Redux store.\r\n *\r\n * @public\r\n */\r\nexport function configureStore<\r\n  S = any,\r\n  A extends Action = AnyAction,\r\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\r\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\r\n  const curriedGetDefaultMiddleware = curryGetDefaultMiddleware<S>()\r\n\r\n  const {\r\n    reducer = undefined,\r\n    middleware = curriedGetDefaultMiddleware(),\r\n    devTools = true,\r\n    preloadedState = undefined,\r\n    enhancers = undefined,\r\n  } = options || {}\r\n\r\n  let rootReducer: Reducer<S, A>\r\n\r\n  if (typeof reducer === 'function') {\r\n    rootReducer = reducer\r\n  } else if (isPlainObject(reducer)) {\r\n    rootReducer = combineReducers(reducer)\r\n  } else {\r\n    throw new Error(\r\n      '\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\r\n    )\r\n  }\r\n\r\n  let finalMiddleware = middleware\r\n  if (typeof finalMiddleware === 'function') {\r\n    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware)\r\n\r\n    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\r\n      throw new Error(\r\n        'when using a middleware builder function, an array of middleware must be returned'\r\n      )\r\n    }\r\n  }\r\n  if (\r\n    !IS_PRODUCTION &&\r\n    finalMiddleware.some((item: any) => typeof item !== 'function')\r\n  ) {\r\n    throw new Error(\r\n      'each middleware provided to configureStore must be a function'\r\n    )\r\n  }\r\n\r\n  const middlewareEnhancer = applyMiddleware(...finalMiddleware)\r\n\r\n  let finalCompose = compose\r\n\r\n  if (devTools) {\r\n    finalCompose = composeWithDevTools({\r\n      // Enable capture of stack traces for dispatched Redux actions\r\n      trace: !IS_PRODUCTION,\r\n      ...(typeof devTools === 'object' && devTools),\r\n    })\r\n  }\r\n\r\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\r\n\r\n  if (Array.isArray(enhancers)) {\r\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\r\n  } else if (typeof enhancers === 'function') {\r\n    storeEnhancers = enhancers(storeEnhancers)\r\n  }\r\n\r\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\r\n\r\n  return createStore(rootReducer, preloadedState, composedEnhancer)\r\n}\r\n","import type { Action } from 'redux'\r\nimport type {\r\n  IsUnknownOrNonInferrable,\r\n  IfMaybeUndefined,\r\n  IfVoid,\r\n  IsAny,\r\n} from './tsHelpers'\r\nimport isPlainObject from './isPlainObject'\r\n\r\n/**\r\n * An action with a string type and an associated payload. This is the\r\n * type of action returned by `createAction()` action creators.\r\n *\r\n * @template P The type of the action's payload.\r\n * @template T the type used for the action type.\r\n * @template M The type of the action's meta (optional)\r\n * @template E The type of the action's error (optional)\r\n *\r\n * @public\r\n */\r\nexport type PayloadAction<\r\n  P = void,\r\n  T extends string = string,\r\n  M = never,\r\n  E = never\r\n> = {\r\n  payload: P\r\n  type: T\r\n} & ([M] extends [never]\r\n  ? {}\r\n  : {\r\n      meta: M\r\n    }) &\r\n  ([E] extends [never]\r\n    ? {}\r\n    : {\r\n        error: E\r\n      })\r\n\r\n/**\r\n * A \"prepare\" method to be used as the second parameter of `createAction`.\r\n * Takes any number of arguments and returns a Flux Standard Action without\r\n * type (will be added later) that *must* contain a payload (might be undefined).\r\n *\r\n * @public\r\n */\r\nexport type PrepareAction<P> =\r\n  | ((...args: any[]) => { payload: P })\r\n  | ((...args: any[]) => { payload: P; meta: any })\r\n  | ((...args: any[]) => { payload: P; error: any })\r\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\r\n\r\n/**\r\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\r\n *\r\n * @internal\r\n */\r\nexport type _ActionCreatorWithPreparedPayload<\r\n  PA extends PrepareAction<any> | void,\r\n  T extends string = string\r\n> = PA extends PrepareAction<infer P>\r\n  ? ActionCreatorWithPreparedPayload<\r\n      Parameters<PA>,\r\n      P,\r\n      T,\r\n      ReturnType<PA> extends {\r\n        error: infer E\r\n      }\r\n        ? E\r\n        : never,\r\n      ReturnType<PA> extends {\r\n        meta: infer M\r\n      }\r\n        ? M\r\n        : never\r\n    >\r\n  : void\r\n\r\n/**\r\n * Basic type for all action creators.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n */\r\nexport interface BaseActionCreator<P, T extends string, M = never, E = never> {\r\n  type: T\r\n  match: (action: Action<unknown>) => action is PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator that takes multiple arguments that are passed\r\n * to a `PrepareAction` method to create the final Action.\r\n * @typeParam Args arguments for the action creator function\r\n * @typeParam P `payload` type\r\n * @typeParam T `type` name\r\n * @typeParam E optional `error` type\r\n * @typeParam M optional `meta` type\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPreparedPayload<\r\n  Args extends unknown[],\r\n  P,\r\n  T extends string = string,\r\n  E = never,\r\n  M = never\r\n> extends BaseActionCreator<P, T, M, E> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with `Args` will return\r\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\r\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\r\n   */\r\n  (...args: Args): PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes an optional payload of type `P`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\r\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\r\n   */\r\n  (payload?: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes no payload.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithoutPayload<T extends string = string>\r\n  extends BaseActionCreator<undefined, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\r\n   */\r\n  (): PayloadAction<undefined, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that requires a payload of type P.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\r\n   */\r\n  (payload: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithNonInferrablePayload<\r\n  T extends string = string\r\n> extends BaseActionCreator<unknown, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload\r\n   * of exactly the type of the argument.\r\n   */\r\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\r\n}\r\n\r\n/**\r\n * An action creator that produces actions with a `payload` attribute.\r\n *\r\n * @typeParam P the `payload` type\r\n * @typeParam T the `type` of the resulting action\r\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\r\n *\r\n * @public\r\n */\r\nexport type PayloadActionCreator<\r\n  P = void,\r\n  T extends string = string,\r\n  PA extends PrepareAction<P> | void = void\r\n> = IfPrepareActionMethodProvided<\r\n  PA,\r\n  _ActionCreatorWithPreparedPayload<PA, T>,\r\n  // else\r\n  IsAny<\r\n    P,\r\n    ActionCreatorWithPayload<any, T>,\r\n    IsUnknownOrNonInferrable<\r\n      P,\r\n      ActionCreatorWithNonInferrablePayload<T>,\r\n      // else\r\n      IfVoid<\r\n        P,\r\n        ActionCreatorWithoutPayload<T>,\r\n        // else\r\n        IfMaybeUndefined<\r\n          P,\r\n          ActionCreatorWithOptionalPayload<P, T>,\r\n          // else\r\n          ActionCreatorWithPayload<P, T>\r\n        >\r\n      >\r\n    >\r\n  >\r\n>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<P = void, T extends string = string>(\r\n  type: T\r\n): PayloadActionCreator<P, T>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<\r\n  PA extends PrepareAction<any>,\r\n  T extends string = string\r\n>(\r\n  type: T,\r\n  prepareAction: PA\r\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\r\n\r\nexport function createAction(type: string, prepareAction?: Function): any {\r\n  function actionCreator(...args: any[]) {\r\n    if (prepareAction) {\r\n      let prepared = prepareAction(...args)\r\n      if (!prepared) {\r\n        throw new Error('prepareAction did not return an object')\r\n      }\r\n\r\n      return {\r\n        type,\r\n        payload: prepared.payload,\r\n        ...('meta' in prepared && { meta: prepared.meta }),\r\n        ...('error' in prepared && { error: prepared.error }),\r\n      }\r\n    }\r\n    return { type, payload: args[0] }\r\n  }\r\n\r\n  actionCreator.toString = () => `${type}`\r\n\r\n  actionCreator.type = type\r\n\r\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\r\n    action.type === type\r\n\r\n  return actionCreator\r\n}\r\n\r\nexport function isFSA(action: unknown): action is {\r\n  type: string\r\n  payload?: unknown\r\n  error?: unknown\r\n  meta?: unknown\r\n} {\r\n  return (\r\n    isPlainObject(action) &&\r\n    typeof (action as any).type === 'string' &&\r\n    Object.keys(action).every(isValidKey)\r\n  )\r\n}\r\n\r\nfunction isValidKey(key: string) {\r\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\r\n}\r\n\r\n/**\r\n * Returns the action type of the actions created by the passed\r\n * `createAction()`-generated action creator (arbitrary action creators\r\n * are not supported).\r\n *\r\n * @param action The action creator whose action type to get.\r\n * @returns The action type used by the action creator.\r\n *\r\n * @public\r\n */\r\nexport function getType<T extends string>(\r\n  actionCreator: PayloadActionCreator<any, T>\r\n): T {\r\n  return `${actionCreator}` as T\r\n}\r\n\r\n// helper types for more readable typings\r\n\r\ntype IfPrepareActionMethodProvided<\r\n  PA extends PrepareAction<any> | void,\r\n  True,\r\n  False\r\n> = PA extends (...args: any[]) => any ? True : False\r\n","import type { Action, AnyAction } from 'redux'\r\nimport type {\r\n  CaseReducer,\r\n  CaseReducers,\r\n  ActionMatcherDescriptionCollection,\r\n} from './createReducer'\r\nimport type { TypeGuard } from './tsHelpers'\r\n\r\nexport interface TypedActionCreator<Type extends string> {\r\n  (...args: any[]): Action<Type>\r\n  type: Type\r\n}\r\n\r\n/**\r\n * A builder for an action <-> reducer map.\r\n *\r\n * @public\r\n */\r\nexport interface ActionReducerMapBuilder<State> {\r\n  /**\r\n   * Adds a case reducer to handle a single exact action type.\r\n   * @remarks\r\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\r\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\r\n   * @param reducer - The actual case reducer function.\r\n   */\r\n  addCase<ActionCreator extends TypedActionCreator<string>>(\r\n    actionCreator: ActionCreator,\r\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\r\n  ): ActionReducerMapBuilder<State>\r\n  /**\r\n   * Adds a case reducer to handle a single exact action type.\r\n   * @remarks\r\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\r\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\r\n   * @param reducer - The actual case reducer function.\r\n   */\r\n  addCase<Type extends string, A extends Action<Type>>(\r\n    type: Type,\r\n    reducer: CaseReducer<State, A>\r\n  ): ActionReducerMapBuilder<State>\r\n\r\n  /**\r\n   * Allows you to match your incoming actions against your own filter function instead of only the `action.type` property.\r\n   * @remarks\r\n   * If multiple matcher reducers match, all of them will be executed in the order\r\n   * they were defined in - even if a case reducer already matched.\r\n   * All calls to `builder.addMatcher` must come after any calls to `builder.addCase` and before any calls to `builder.addDefaultCase`.\r\n   * @param matcher - A matcher function. In TypeScript, this should be a [type predicate](https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates)\r\n   *   function\r\n   * @param reducer - The actual case reducer function.\r\n   *\r\n   * @example\r\n```ts\r\nimport {\r\n  createAction,\r\n  createReducer,\r\n  AsyncThunk,\r\n  AnyAction,\r\n} from \"@reduxjs/toolkit\";\r\n\r\ntype GenericAsyncThunk = AsyncThunk<unknown, unknown, any>;\r\n\r\ntype PendingAction = ReturnType<GenericAsyncThunk[\"pending\"]>;\r\ntype RejectedAction = ReturnType<GenericAsyncThunk[\"rejected\"]>;\r\ntype FulfilledAction = ReturnType<GenericAsyncThunk[\"fulfilled\"]>;\r\n\r\nconst initialState: Record<string, string> = {};\r\nconst resetAction = createAction(\"reset-tracked-loading-state\");\r\n\r\nfunction isPendingAction(action: AnyAction): action is PendingAction {\r\n  return action.type.endsWith(\"/pending\");\r\n}\r\n\r\nconst reducer = createReducer(initialState, (builder) => {\r\n  builder\r\n    .addCase(resetAction, () => initialState)\r\n    // matcher can be defined outside as a type predicate function\r\n    .addMatcher(isPendingAction, (state, action) => {\r\n      state[action.meta.requestId] = \"pending\";\r\n    })\r\n    .addMatcher(\r\n      // matcher can be defined inline as a type predicate function\r\n      (action): action is RejectedAction => action.type.endsWith(\"/rejected\"),\r\n      (state, action) => {\r\n        state[action.meta.requestId] = \"rejected\";\r\n      }\r\n    )\r\n    // matcher can just return boolean and the matcher can receive a generic argument\r\n    .addMatcher<FulfilledAction>(\r\n      (action) => action.type.endsWith(\"/fulfilled\"),\r\n      (state, action) => {\r\n        state[action.meta.requestId] = \"fulfilled\";\r\n      }\r\n    );\r\n});\r\n```\r\n   */\r\n  addMatcher<A>(\r\n    matcher: TypeGuard<A> | ((action: any) => boolean),\r\n    reducer: CaseReducer<State, A extends AnyAction ? A : A & AnyAction>\r\n  ): Omit<ActionReducerMapBuilder<State>, 'addCase'>\r\n\r\n  /**\r\n   * Adds a \"default case\" reducer that is executed if no case reducer and no matcher\r\n   * reducer was executed for this action.\r\n   * @param reducer - The fallback \"default case\" reducer function.\r\n   *\r\n   * @example\r\n```ts\r\nimport { createReducer } from '@reduxjs/toolkit'\r\nconst initialState = { otherActions: 0 }\r\nconst reducer = createReducer(initialState, builder => {\r\n  builder\r\n    // .addCase(...)\r\n    // .addMatcher(...)\r\n    .addDefaultCase((state, action) => {\r\n      state.otherActions++\r\n    })\r\n})\r\n```\r\n   */\r\n  addDefaultCase(reducer: CaseReducer<State, AnyAction>): {}\r\n}\r\n\r\nexport function executeReducerBuilderCallback<S>(\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): [\r\n  CaseReducers<S, any>,\r\n  ActionMatcherDescriptionCollection<S>,\r\n  CaseReducer<S, AnyAction> | undefined\r\n] {\r\n  const actionsMap: CaseReducers<S, any> = {}\r\n  const actionMatchers: ActionMatcherDescriptionCollection<S> = []\r\n  let defaultCaseReducer: CaseReducer<S, AnyAction> | undefined\r\n  const builder = {\r\n    addCase(\r\n      typeOrActionCreator: string | TypedActionCreator<any>,\r\n      reducer: CaseReducer<S>\r\n    ) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        /*\r\n         to keep the definition by the user in line with actual behavior, \r\n         we enforce `addCase` to always be called before calling `addMatcher`\r\n         as matching cases take precedence over matchers\r\n         */\r\n        if (actionMatchers.length > 0) {\r\n          throw new Error(\r\n            '`builder.addCase` should only be called before calling `builder.addMatcher`'\r\n          )\r\n        }\r\n        if (defaultCaseReducer) {\r\n          throw new Error(\r\n            '`builder.addCase` should only be called before calling `builder.addDefaultCase`'\r\n          )\r\n        }\r\n      }\r\n      const type =\r\n        typeof typeOrActionCreator === 'string'\r\n          ? typeOrActionCreator\r\n          : typeOrActionCreator.type\r\n      if (type in actionsMap) {\r\n        throw new Error(\r\n          'addCase cannot be called with two reducers for the same action type'\r\n        )\r\n      }\r\n      actionsMap[type] = reducer\r\n      return builder\r\n    },\r\n    addMatcher<A>(\r\n      matcher: TypeGuard<A>,\r\n      reducer: CaseReducer<S, A extends AnyAction ? A : A & AnyAction>\r\n    ) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (defaultCaseReducer) {\r\n          throw new Error(\r\n            '`builder.addMatcher` should only be called before calling `builder.addDefaultCase`'\r\n          )\r\n        }\r\n      }\r\n      actionMatchers.push({ matcher, reducer })\r\n      return builder\r\n    },\r\n    addDefaultCase(reducer: CaseReducer<S, AnyAction>) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (defaultCaseReducer) {\r\n          throw new Error('`builder.addDefaultCase` can only be called once')\r\n        }\r\n      }\r\n      defaultCaseReducer = reducer\r\n      return builder\r\n    },\r\n  }\r\n  builderCallback(builder)\r\n  return [actionsMap, actionMatchers, defaultCaseReducer]\r\n}\r\n","import type { AnyAction, Reducer } from 'redux'\r\nimport { createNextState } from '.'\r\nimport type {\r\n  ActionCreatorWithoutPayload,\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  PrepareAction,\r\n  _ActionCreatorWithPreparedPayload,\r\n} from './createAction'\r\nimport { createAction } from './createAction'\r\nimport type {\r\n  CaseReducer,\r\n  CaseReducers,\r\n  ReducerWithInitialState,\r\n} from './createReducer'\r\nimport { createReducer, NotFunction } from './createReducer'\r\nimport type { ActionReducerMapBuilder } from './mapBuilders'\r\nimport { executeReducerBuilderCallback } from './mapBuilders'\r\nimport type { NoInfer } from './tsHelpers'\r\n\r\n/**\r\n * An action creator attached to a slice.\r\n *\r\n * @deprecated please use PayloadActionCreator directly\r\n *\r\n * @public\r\n */\r\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\r\n\r\n/**\r\n * The return value of `createSlice`\r\n *\r\n * @public\r\n */\r\nexport interface Slice<\r\n  State = any,\r\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice name.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The slice's reducer.\r\n   */\r\n  reducer: Reducer<State>\r\n\r\n  /**\r\n   * Action creators for the types of actions that are handled by the slice\r\n   * reducer.\r\n   */\r\n  actions: CaseReducerActions<CaseReducers>\r\n\r\n  /**\r\n   * The individual case reducer functions that were passed in the `reducers` parameter.\r\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\r\n   */\r\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\r\n\r\n  /**\r\n   * Provides access to the initial state value given to the slice.\r\n   * If a lazy state initializer was provided, it will be called and a fresh value returned.\r\n   */\r\n  getInitialState: () => State\r\n}\r\n\r\n/**\r\n * Options for `createSlice()`.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSliceOptions<\r\n  State = any,\r\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice's name. Used to namespace the generated action types.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The initial state that should be used when the reducer is called the first time. This may also be a \"lazy initializer\" function, which should return an initial state value when called. This will be used whenever the reducer is called with `undefined` as its state value, and is primarily useful for cases like reading initial state from `localStorage`.\r\n   */\r\n  initialState: State | (() => State)\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. For every action type, a matching action creator will be\r\n   * generated using `createAction()`.\r\n   */\r\n  reducers: ValidateSliceCaseReducers<State, CR>\r\n\r\n  /**\r\n   * A callback that receives a *builder* object to define\r\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n   * \r\n   * Alternatively, a mapping from action types to action-type-specific *case reducer*\r\n   * functions. These reducers should have existing action types used\r\n   * as the keys, and action creators will _not_ be generated.\r\n   * \r\n   * @example\r\n```ts\r\nimport { createAction, createSlice, Action, AnyAction } from '@reduxjs/toolkit'\r\nconst incrementBy = createAction<number>('incrementBy')\r\nconst decrement = createAction('decrement')\r\n\r\ninterface RejectedAction extends Action {\r\n  error: Error\r\n}\r\n\r\nfunction isRejectedAction(action: AnyAction): action is RejectedAction {\r\n  return action.type.endsWith('rejected')\r\n}\r\n\r\ncreateSlice({\r\n  name: 'counter',\r\n  initialState: 0,\r\n  reducers: {},\r\n  extraReducers: builder => {\r\n    builder\r\n      .addCase(incrementBy, (state, action) => {\r\n        // action is inferred correctly here if using TS\r\n      })\r\n      // You can chain calls, or have separate `builder.addCase()` lines each time\r\n      .addCase(decrement, (state, action) => {})\r\n      // You can match a range of action types\r\n      .addMatcher(\r\n        isRejectedAction,\r\n        // `action` will be inferred as a RejectedAction due to isRejectedAction being defined as a type guard\r\n        (state, action) => {}\r\n      )\r\n      // and provide a default case if no other handlers matched\r\n      .addDefaultCase((state, action) => {})\r\n    }\r\n})\r\n```\r\n   */\r\n  extraReducers?:\r\n    | CaseReducers<NoInfer<State>, any>\r\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\r\n}\r\n\r\n/**\r\n * A CaseReducer with a `prepare` method.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\r\n  reducer: CaseReducer<State, Action>\r\n  prepare: PrepareAction<Action['payload']>\r\n}\r\n\r\n/**\r\n * The type describing a slice's `reducers` option.\r\n *\r\n * @public\r\n */\r\nexport type SliceCaseReducers<State> = {\r\n  [K: string]:\r\n    | CaseReducer<State, PayloadAction<any>>\r\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\r\n}\r\n\r\n/**\r\n * Derives the slice's `actions` property from the `reducers` options\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\r\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\r\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\r\n}\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducerWithPrepare<CR extends { prepare: any }> =\r\n  _ActionCreatorWithPreparedPayload<CR['prepare'], string>\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducer<CR> = CR extends (\r\n  state: any,\r\n  action: infer Action\r\n) => any\r\n  ? Action extends { payload: infer P }\r\n    ? PayloadActionCreator<P>\r\n    : ActionCreatorWithoutPayload\r\n  : ActionCreatorWithoutPayload\r\n\r\n/**\r\n * Extracts the CaseReducers out of a `reducers` object, even if they are\r\n * tested into a `CaseReducerWithPrepare`.\r\n *\r\n * @internal\r\n */\r\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\r\n    reducer: infer Reducer\r\n  }\r\n    ? Reducer\r\n    : CaseReducers[Type]\r\n}\r\n\r\n/**\r\n * Used on a SliceCaseReducers object.\r\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\r\n * the `reducer` and the `prepare` function use the same type of `payload`.\r\n *\r\n * Might do additional such checks in the future.\r\n *\r\n * This type is only ever useful if you want to write your own wrapper around\r\n * `createSlice`. Please don't use it otherwise!\r\n *\r\n * @public\r\n */\r\nexport type ValidateSliceCaseReducers<\r\n  S,\r\n  ACR extends SliceCaseReducers<S>\r\n> = ACR &\r\n  {\r\n    [T in keyof ACR]: ACR[T] extends {\r\n      reducer(s: S, action?: infer A): any\r\n    }\r\n      ? {\r\n          prepare(...a: never[]): Omit<A, 'type'>\r\n        }\r\n      : {}\r\n  }\r\n\r\nfunction getType(slice: string, actionKey: string): string {\r\n  return `${slice}/${actionKey}`\r\n}\r\n\r\n/**\r\n * A function that accepts an initial state, an object full of reducer\r\n * functions, and a \"slice name\", and automatically generates\r\n * action creators and action types that correspond to the\r\n * reducers and state.\r\n *\r\n * The `reducer` argument is passed to `createReducer()`.\r\n *\r\n * @public\r\n */\r\nexport function createSlice<\r\n  State,\r\n  CaseReducers extends SliceCaseReducers<State>,\r\n  Name extends string = string\r\n>(\r\n  options: CreateSliceOptions<State, CaseReducers, Name>\r\n): Slice<State, CaseReducers, Name> {\r\n  const { name } = options\r\n  if (!name) {\r\n    throw new Error('`name` is a required option for createSlice')\r\n  }\r\n  const initialState =\r\n    typeof options.initialState == 'function'\r\n      ? options.initialState\r\n      : createNextState(options.initialState, () => {})\r\n\r\n  const reducers = options.reducers || {}\r\n\r\n  const reducerNames = Object.keys(reducers)\r\n\r\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\r\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\r\n  const actionCreators: Record<string, Function> = {}\r\n\r\n  reducerNames.forEach((reducerName) => {\r\n    const maybeReducerWithPrepare = reducers[reducerName]\r\n    const type = getType(name, reducerName)\r\n\r\n    let caseReducer: CaseReducer<State, any>\r\n    let prepareCallback: PrepareAction<any> | undefined\r\n\r\n    if ('reducer' in maybeReducerWithPrepare) {\r\n      caseReducer = maybeReducerWithPrepare.reducer\r\n      prepareCallback = maybeReducerWithPrepare.prepare\r\n    } else {\r\n      caseReducer = maybeReducerWithPrepare\r\n    }\r\n\r\n    sliceCaseReducersByName[reducerName] = caseReducer\r\n    sliceCaseReducersByType[type] = caseReducer\r\n    actionCreators[reducerName] = prepareCallback\r\n      ? createAction(type, prepareCallback)\r\n      : createAction(type)\r\n  })\r\n\r\n  function buildReducer() {\r\n    const [\r\n      extraReducers = {},\r\n      actionMatchers = [],\r\n      defaultCaseReducer = undefined,\r\n    ] =\r\n      typeof options.extraReducers === 'function'\r\n        ? executeReducerBuilderCallback(options.extraReducers)\r\n        : [options.extraReducers]\r\n\r\n    const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\r\n    return createReducer(\r\n      initialState,\r\n      finalCaseReducers as any,\r\n      actionMatchers,\r\n      defaultCaseReducer\r\n    )\r\n  }\r\n\r\n  let _reducer: ReducerWithInitialState<State>\r\n\r\n  return {\r\n    name,\r\n    reducer(state, action) {\r\n      if (!_reducer) _reducer = buildReducer()\r\n\r\n      return _reducer(state, action)\r\n    },\r\n    actions: actionCreators as any,\r\n    caseReducers: sliceCaseReducersByName as any,\r\n    getInitialState() {\r\n      if (!_reducer) _reducer = buildReducer()\r\n\r\n      return _reducer.getInitialState()\r\n    },\r\n  }\r\n}\r\n","import type { Draft } from 'immer'\r\nimport createNextState, { isDraft, isDraftable } from 'immer'\r\nimport type { AnyAction, Action, Reducer } from 'redux'\r\nimport type { ActionReducerMapBuilder } from './mapBuilders'\r\nimport { executeReducerBuilderCallback } from './mapBuilders'\r\nimport type { NoInfer } from './tsHelpers'\r\n\r\n/**\r\n * Defines a mapping from action types to corresponding action object shapes.\r\n *\r\n * @deprecated This should not be used manually - it is only used for internal\r\n *             inference purposes and should not have any further value.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type Actions<T extends keyof any = string> = Record<T, Action>\r\n\r\n/**\r\n * @deprecated use `TypeGuard` instead\r\n */\r\nexport interface ActionMatcher<A extends AnyAction> {\r\n  (action: AnyAction): action is A\r\n}\r\n\r\nexport type ActionMatcherDescription<S, A extends AnyAction> = {\r\n  matcher: ActionMatcher<A>\r\n  reducer: CaseReducer<S, NoInfer<A>>\r\n}\r\n\r\nexport type ReadonlyActionMatcherDescriptionCollection<S> = ReadonlyArray<\r\n  ActionMatcherDescription<S, any>\r\n>\r\n\r\nexport type ActionMatcherDescriptionCollection<S> = Array<\r\n  ActionMatcherDescription<S, any>\r\n>\r\n\r\n/**\r\n * An *case reducer* is a reducer function for a specific action type. Case\r\n * reducers can be composed to full reducers using `createReducer()`.\r\n *\r\n * Unlike a normal Redux reducer, a case reducer is never called with an\r\n * `undefined` state to determine the initial state. Instead, the initial\r\n * state is explicitly specified as an argument to `createReducer()`.\r\n *\r\n * In addition, a case reducer can choose to mutate the passed-in `state`\r\n * value directly instead of returning a new state. This does not actually\r\n * cause the store state to be mutated directly; instead, thanks to\r\n * [immer](https://github.com/mweststrate/immer), the mutations are\r\n * translated to copy operations that result in a new state.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\r\n  state: Draft<S>,\r\n  action: A\r\n) => S | void | Draft<S>\r\n\r\n/**\r\n * A mapping from action types to case reducers for `createReducer()`.\r\n *\r\n * @deprecated This should not be used manually - it is only used\r\n *             for internal inference purposes and using it manually\r\n *             would lead to type erasure.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type CaseReducers<S, AS extends Actions> = {\r\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\r\n}\r\n\r\nexport type NotFunction<T> = T extends Function ? never : T\r\n\r\nfunction isStateFunction<S>(x: unknown): x is () => S {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport type ReducerWithInitialState<S extends NotFunction<any>> = Reducer<S> & {\r\n  getInitialState: () => S\r\n}\r\n\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * @remarks\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n *\r\n * @overloadSummary\r\n * This overload accepts a callback function that receives a `builder` object as its argument.\r\n * That builder provides `addCase`, `addMatcher` and `addDefaultCase` functions that may be\r\n * called to define what actions this reducer will handle.\r\n *\r\n * @param initialState - `State | (() => State)`: The initial state that should be used when the reducer is called the first time. This may also be a \"lazy initializer\" function, which should return an initial state value when called. This will be used whenever the reducer is called with `undefined` as its state value, and is primarily useful for cases like reading initial state from `localStorage`.\r\n * @param builderCallback - `(builder: Builder) => void` A callback that receives a *builder* object to define\r\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n * @example\r\n```ts\r\nimport {\r\n  createAction,\r\n  createReducer,\r\n  AnyAction,\r\n  PayloadAction,\r\n} from \"@reduxjs/toolkit\";\r\n\r\nconst increment = createAction<number>(\"increment\");\r\nconst decrement = createAction<number>(\"decrement\");\r\n\r\nfunction isActionWithNumberPayload(\r\n  action: AnyAction\r\n): action is PayloadAction<number> {\r\n  return typeof action.payload === \"number\";\r\n}\r\n\r\nconst reducer = createReducer(\r\n  {\r\n    counter: 0,\r\n    sumOfNumberPayloads: 0,\r\n    unhandledActions: 0,\r\n  },\r\n  (builder) => {\r\n    builder\r\n      .addCase(increment, (state, action) => {\r\n        // action is inferred correctly here\r\n        state.counter += action.payload;\r\n      })\r\n      // You can chain calls, or have separate `builder.addCase()` lines each time\r\n      .addCase(decrement, (state, action) => {\r\n        state.counter -= action.payload;\r\n      })\r\n      // You can apply a \"matcher function\" to incoming actions\r\n      .addMatcher(isActionWithNumberPayload, (state, action) => {})\r\n      // and provide a default case if no other handlers matched\r\n      .addDefaultCase((state, action) => {});\r\n  }\r\n);\r\n```\r\n * @public\r\n */\r\nexport function createReducer<S extends NotFunction<any>>(\r\n  initialState: S | (() => S),\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): ReducerWithInitialState<S>\r\n\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n * \r\n * @overloadSummary\r\n * This overload accepts an object where the keys are string action types, and the values\r\n * are case reducer functions to handle those action types.\r\n *\r\n * @param initialState - `State | (() => State)`: The initial state that should be used when the reducer is called the first time. This may also be a \"lazy initializer\" function, which should return an initial state value when called. This will be used whenever the reducer is called with `undefined` as its state value, and is primarily useful for cases like reading initial state from `localStorage`.\r\n * @param actionsMap - An object mapping from action types to _case reducers_, each of which handles one specific action type.\r\n * @param actionMatchers - An array of matcher definitions in the form `{matcher, reducer}`.\r\n *   All matching reducers will be executed in order, independently if a case reducer matched or not.\r\n * @param defaultCaseReducer - A \"default case\" reducer that is executed if no case reducer and no matcher\r\n *   reducer was executed for this action.\r\n *\r\n * @example\r\n```js\r\nconst counterReducer = createReducer(0, {\r\n  increment: (state, action) => state + action.payload,\r\n  decrement: (state, action) => state - action.payload\r\n})\r\n\r\n// Alternately, use a \"lazy initializer\" to provide the initial state\r\n// (works with either form of createReducer)\r\nconst initialState = () => 0\r\nconst counterReducer = createReducer(initialState, {\r\n  increment: (state, action) => state + action.payload,\r\n  decrement: (state, action) => state - action.payload\r\n})\r\n```\r\n \r\n * Action creators that were generated using [`createAction`](./createAction) may be used directly as the keys here, using computed property syntax:\r\n\r\n```js\r\nconst increment = createAction('increment')\r\nconst decrement = createAction('decrement')\r\n\r\nconst counterReducer = createReducer(0, {\r\n  [increment]: (state, action) => state + action.payload,\r\n  [decrement.type]: (state, action) => state - action.payload\r\n})\r\n```\r\n * @public\r\n */\r\nexport function createReducer<\r\n  S extends NotFunction<any>,\r\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\r\n>(\r\n  initialState: S | (() => S),\r\n  actionsMap: CR,\r\n  actionMatchers?: ActionMatcherDescriptionCollection<S>,\r\n  defaultCaseReducer?: CaseReducer<S>\r\n): ReducerWithInitialState<S>\r\n\r\nexport function createReducer<S extends NotFunction<any>>(\r\n  initialState: S | (() => S),\r\n  mapOrBuilderCallback:\r\n    | CaseReducers<S, any>\r\n    | ((builder: ActionReducerMapBuilder<S>) => void),\r\n  actionMatchers: ReadonlyActionMatcherDescriptionCollection<S> = [],\r\n  defaultCaseReducer?: CaseReducer<S>\r\n): ReducerWithInitialState<S> {\r\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] =\r\n    typeof mapOrBuilderCallback === 'function'\r\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\r\n      : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer]\r\n\r\n  // Ensure the initial state gets frozen either way\r\n  let getInitialState: () => S\r\n  if (isStateFunction(initialState)) {\r\n    getInitialState = () => createNextState(initialState(), () => {})\r\n  } else {\r\n    const frozenInitialState = createNextState(initialState, () => {})\r\n    getInitialState = () => frozenInitialState\r\n  }\r\n\r\n  function reducer(state = getInitialState(), action: any): S {\r\n    let caseReducers = [\r\n      actionsMap[action.type],\r\n      ...finalActionMatchers\r\n        .filter(({ matcher }) => matcher(action))\r\n        .map(({ reducer }) => reducer),\r\n    ]\r\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\r\n      caseReducers = [finalDefaultCaseReducer]\r\n    }\r\n\r\n    return caseReducers.reduce((previousState, caseReducer): S => {\r\n      if (caseReducer) {\r\n        if (isDraft(previousState)) {\r\n          // If it's already a draft, we must already be inside a `createNextState` call,\r\n          // likely because this is being wrapped in `createReducer`, `createSlice`, or nested\r\n          // inside an existing draft. It's safe to just pass the draft to the mutator.\r\n          const draft = previousState as Draft<S> // We can assume this is already a draft\r\n          const result = caseReducer(draft, action)\r\n\r\n          if (typeof result === 'undefined') {\r\n            return previousState\r\n          }\r\n\r\n          return result as S\r\n        } else if (!isDraftable(previousState)) {\r\n          // If state is not draftable (ex: a primitive, such as 0), we want to directly\r\n          // return the caseReducer func and not wrap it with produce.\r\n          const result = caseReducer(previousState as any, action)\r\n\r\n          if (typeof result === 'undefined') {\r\n            if (previousState === null) {\r\n              return previousState\r\n            }\r\n            throw Error(\r\n              'A case reducer on a non-draftable value must not return undefined'\r\n            )\r\n          }\r\n\r\n          return result as S\r\n        } else {\r\n          // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\r\n          // than an Immutable<S>, and TypeScript cannot find out how to reconcile\r\n          // these two types.\r\n          return createNextState(previousState, (draft: Draft<S>) => {\r\n            return caseReducer(draft, action)\r\n          })\r\n        }\r\n      }\r\n\r\n      return previousState\r\n    }, state)\r\n  }\r\n\r\n  reducer.getInitialState = getInitialState\r\n\r\n  return reducer as ReducerWithInitialState<S>\r\n}\r\n","import type { Dispatch, AnyAction, MiddlewareAPI } from 'redux'\r\nimport type { ThunkDispatch } from 'redux-thunk'\r\nimport { createAction } from '../createAction'\r\nimport { nanoid } from '../nanoid'\r\n\r\nimport type {\r\n  ListenerMiddleware,\r\n  ListenerMiddlewareInstance,\r\n  AddListenerOverloads,\r\n  AnyListenerPredicate,\r\n  CreateListenerMiddlewareOptions,\r\n  TypedAddListener,\r\n  TypedCreateListenerEntry,\r\n  FallbackAddListenerOptions,\r\n  ListenerEntry,\r\n  ListenerErrorHandler,\r\n  UnsubscribeListener,\r\n  TakePattern,\r\n  ListenerErrorInfo,\r\n  ForkedTaskExecutor,\r\n  ForkedTask,\r\n  TypedRemoveListener,\r\n  TaskResult,\r\n  AbortSignalWithReason,\r\n  UnsubscribeListenerOptions,\r\n} from './types'\r\nimport {\r\n  abortControllerWithReason,\r\n  addAbortSignalListener,\r\n  assertFunction,\r\n  catchRejection,\r\n} from './utils'\r\nimport {\r\n  listenerCancelled,\r\n  listenerCompleted,\r\n  TaskAbortError,\r\n  taskCancelled,\r\n  taskCompleted,\r\n} from './exceptions'\r\nimport {\r\n  runTask,\r\n  promisifyAbortSignal,\r\n  validateActive,\r\n  createPause,\r\n  createDelay,\r\n} from './task'\r\nexport { TaskAbortError } from './exceptions'\r\nexport type {\r\n  ListenerEffect,\r\n  ListenerMiddleware,\r\n  ListenerEffectAPI,\r\n  ListenerMiddlewareInstance,\r\n  CreateListenerMiddlewareOptions,\r\n  ListenerErrorHandler,\r\n  TypedStartListening,\r\n  TypedAddListener,\r\n  TypedStopListening,\r\n  TypedRemoveListener,\r\n  UnsubscribeListener,\r\n  UnsubscribeListenerOptions,\r\n  ForkedTaskExecutor,\r\n  ForkedTask,\r\n  ForkedTaskAPI,\r\n  AsyncTaskExecutor,\r\n  SyncTaskExecutor,\r\n  TaskCancelled,\r\n  TaskRejected,\r\n  TaskResolved,\r\n  TaskResult,\r\n} from './types'\r\n\r\n//Overly-aggressive byte-shaving\r\nconst { assign } = Object\r\n/**\r\n * @internal\r\n */\r\nconst INTERNAL_NIL_TOKEN = {} as const\r\n\r\nconst alm = 'listenerMiddleware' as const\r\n\r\nconst createFork = (parentAbortSignal: AbortSignalWithReason<unknown>) => {\r\n  const linkControllers = (controller: AbortController) =>\r\n    addAbortSignalListener(parentAbortSignal, () =>\r\n      abortControllerWithReason(controller, parentAbortSignal.reason)\r\n    )\r\n\r\n  return <T>(taskExecutor: ForkedTaskExecutor<T>): ForkedTask<T> => {\r\n    assertFunction(taskExecutor, 'taskExecutor')\r\n    const childAbortController = new AbortController()\r\n\r\n    linkControllers(childAbortController)\r\n\r\n    const result = runTask<T>(\r\n      async (): Promise<T> => {\r\n        validateActive(parentAbortSignal)\r\n        validateActive(childAbortController.signal)\r\n        const result = (await taskExecutor({\r\n          pause: createPause(childAbortController.signal),\r\n          delay: createDelay(childAbortController.signal),\r\n          signal: childAbortController.signal,\r\n        })) as T\r\n        validateActive(childAbortController.signal)\r\n        return result\r\n      },\r\n      () => abortControllerWithReason(childAbortController, taskCompleted)\r\n    )\r\n\r\n    return {\r\n      result: createPause<TaskResult<T>>(parentAbortSignal)(result),\r\n      cancel() {\r\n        abortControllerWithReason(childAbortController, taskCancelled)\r\n      },\r\n    }\r\n  }\r\n}\r\n\r\nconst createTakePattern = <S>(\r\n  startListening: AddListenerOverloads<\r\n    UnsubscribeListener,\r\n    S,\r\n    Dispatch<AnyAction>\r\n  >,\r\n  signal: AbortSignal\r\n): TakePattern<S> => {\r\n  /**\r\n   * A function that takes a ListenerPredicate and an optional timeout,\r\n   * and resolves when either the predicate returns `true` based on an action\r\n   * state combination or when the timeout expires.\r\n   * If the parent listener is canceled while waiting, this will throw a\r\n   * TaskAbortError.\r\n   */\r\n  const take = async <P extends AnyListenerPredicate<S>>(\r\n    predicate: P,\r\n    timeout: number | undefined\r\n  ) => {\r\n    validateActive(signal)\r\n\r\n    // Placeholder unsubscribe function until the listener is added\r\n    let unsubscribe: UnsubscribeListener = () => {}\r\n\r\n    const tuplePromise = new Promise<[AnyAction, S, S]>((resolve) => {\r\n      // Inside the Promise, we synchronously add the listener.\r\n      unsubscribe = startListening({\r\n        predicate: predicate as any,\r\n        effect: (action, listenerApi): void => {\r\n          // One-shot listener that cleans up as soon as the predicate passes\r\n          listenerApi.unsubscribe()\r\n          // Resolve the promise with the same arguments the predicate saw\r\n          resolve([\r\n            action,\r\n            listenerApi.getState(),\r\n            listenerApi.getOriginalState(),\r\n          ])\r\n        },\r\n      })\r\n    })\r\n\r\n    const promises: (Promise<null> | Promise<[AnyAction, S, S]>)[] = [\r\n      promisifyAbortSignal(signal),\r\n      tuplePromise,\r\n    ]\r\n\r\n    if (timeout != null) {\r\n      promises.push(\r\n        new Promise<null>((resolve) => setTimeout(resolve, timeout, null))\r\n      )\r\n    }\r\n\r\n    try {\r\n      const output = await Promise.race(promises)\r\n\r\n      validateActive(signal)\r\n      return output\r\n    } finally {\r\n      // Always clean up the listener\r\n      unsubscribe()\r\n    }\r\n  }\r\n\r\n  return ((predicate: AnyListenerPredicate<S>, timeout: number | undefined) =>\r\n    catchRejection(take(predicate, timeout))) as TakePattern<S>\r\n}\r\n\r\nconst getListenerEntryPropsFrom = (options: FallbackAddListenerOptions) => {\r\n  let { type, actionCreator, matcher, predicate, effect } = options\r\n\r\n  if (type) {\r\n    predicate = createAction(type).match\r\n  } else if (actionCreator) {\r\n    type = actionCreator!.type\r\n    predicate = actionCreator.match\r\n  } else if (matcher) {\r\n    predicate = matcher\r\n  } else if (predicate) {\r\n    // pass\r\n  } else {\r\n    throw new Error(\r\n      'Creating or removing a listener requires one of the known fields for matching an action'\r\n    )\r\n  }\r\n\r\n  assertFunction(effect, 'options.listener')\r\n\r\n  return { predicate, type, effect }\r\n}\r\n\r\n/** Accepts the possible options for creating a listener, and returns a formatted listener entry */\r\nexport const createListenerEntry: TypedCreateListenerEntry<unknown> = (\r\n  options: FallbackAddListenerOptions\r\n) => {\r\n  const { type, predicate, effect } = getListenerEntryPropsFrom(options)\r\n\r\n  const id = nanoid()\r\n  const entry: ListenerEntry<unknown> = {\r\n    id,\r\n    effect,\r\n    type,\r\n    predicate,\r\n    pending: new Set<AbortController>(),\r\n    unsubscribe: () => {\r\n      throw new Error('Unsubscribe not initialized')\r\n    },\r\n  }\r\n\r\n  return entry\r\n}\r\n\r\nconst createClearListenerMiddleware = (\r\n  listenerMap: Map<string, ListenerEntry>\r\n) => {\r\n  return () => {\r\n    listenerMap.forEach(cancelActiveListeners)\r\n\r\n    listenerMap.clear()\r\n  }\r\n}\r\n\r\n/**\r\n * Safely reports errors to the `errorHandler` provided.\r\n * Errors that occur inside `errorHandler` are notified in a new task.\r\n * Inspired by [rxjs reportUnhandledError](https://github.com/ReactiveX/rxjs/blob/6fafcf53dc9e557439b25debaeadfd224b245a66/src/internal/util/reportUnhandledError.ts)\r\n * @param errorHandler\r\n * @param errorToNotify\r\n */\r\nconst safelyNotifyError = (\r\n  errorHandler: ListenerErrorHandler,\r\n  errorToNotify: unknown,\r\n  errorInfo: ListenerErrorInfo\r\n): void => {\r\n  try {\r\n    errorHandler(errorToNotify, errorInfo)\r\n  } catch (errorHandlerError) {\r\n    // We cannot let an error raised here block the listener queue.\r\n    // The error raised here will be picked up by `window.onerror`, `process.on('error')` etc...\r\n    setTimeout(() => {\r\n      throw errorHandlerError\r\n    }, 0)\r\n  }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const addListener = createAction(\r\n  `${alm}/add`\r\n) as TypedAddListener<unknown>\r\n\r\n/**\r\n * @public\r\n */\r\nexport const clearAllListeners = createAction(`${alm}/removeAll`)\r\n\r\n/**\r\n * @public\r\n */\r\nexport const removeListener = createAction(\r\n  `${alm}/remove`\r\n) as TypedRemoveListener<unknown>\r\n\r\nconst defaultErrorHandler: ListenerErrorHandler = (...args: unknown[]) => {\r\n  console.error(`${alm}/error`, ...args)\r\n}\r\n\r\nconst cancelActiveListeners = (\r\n  entry: ListenerEntry<unknown, Dispatch<AnyAction>>\r\n) => {\r\n  entry.pending.forEach((controller) => {\r\n    abortControllerWithReason(controller, listenerCancelled)\r\n  })\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function createListenerMiddleware<\r\n  S = unknown,\r\n  D extends Dispatch<AnyAction> = ThunkDispatch<S, unknown, AnyAction>,\r\n  ExtraArgument = unknown\r\n>(middlewareOptions: CreateListenerMiddlewareOptions<ExtraArgument> = {}) {\r\n  const listenerMap = new Map<string, ListenerEntry>()\r\n  const { extra, onError = defaultErrorHandler } = middlewareOptions\r\n\r\n  assertFunction(onError, 'onError')\r\n\r\n  const insertEntry = (entry: ListenerEntry) => {\r\n    entry.unsubscribe = () => listenerMap.delete(entry!.id)\r\n\r\n    listenerMap.set(entry.id, entry)\r\n    return (cancelOptions?: UnsubscribeListenerOptions) => {\r\n      entry.unsubscribe()\r\n      if (cancelOptions?.cancelActive) {\r\n        cancelActiveListeners(entry)\r\n      }\r\n    }\r\n  }\r\n\r\n  const findListenerEntry = (\r\n    comparator: (entry: ListenerEntry) => boolean\r\n  ): ListenerEntry | undefined => {\r\n    for (const entry of listenerMap.values()) {\r\n      if (comparator(entry)) {\r\n        return entry\r\n      }\r\n    }\r\n\r\n    return undefined\r\n  }\r\n\r\n  const startListening = (options: FallbackAddListenerOptions) => {\r\n    let entry = findListenerEntry(\r\n      (existingEntry) => existingEntry.effect === options.effect\r\n    )\r\n\r\n    if (!entry) {\r\n      entry = createListenerEntry(options as any)\r\n    }\r\n\r\n    return insertEntry(entry)\r\n  }\r\n\r\n  const stopListening = (\r\n    options: FallbackAddListenerOptions & UnsubscribeListenerOptions\r\n  ): boolean => {\r\n    const { type, effect, predicate } = getListenerEntryPropsFrom(options)\r\n\r\n    const entry = findListenerEntry((entry) => {\r\n      const matchPredicateOrType =\r\n        typeof type === 'string'\r\n          ? entry.type === type\r\n          : entry.predicate === predicate\r\n\r\n      return matchPredicateOrType && entry.effect === effect\r\n    })\r\n\r\n    if (entry) {\r\n      entry.unsubscribe()\r\n      if (options.cancelActive) {\r\n        cancelActiveListeners(entry)\r\n      }\r\n    }\r\n\r\n    return !!entry\r\n  }\r\n\r\n  const notifyListener = async (\r\n    entry: ListenerEntry<unknown, Dispatch<AnyAction>>,\r\n    action: AnyAction,\r\n    api: MiddlewareAPI,\r\n    getOriginalState: () => S\r\n  ) => {\r\n    const internalTaskController = new AbortController()\r\n    const take = createTakePattern(\r\n      startListening,\r\n      internalTaskController.signal\r\n    )\r\n\r\n    try {\r\n      entry.pending.add(internalTaskController)\r\n      await Promise.resolve(\r\n        entry.effect(\r\n          action,\r\n          // Use assign() rather than ... to avoid extra helper functions added to bundle\r\n          assign({}, api, {\r\n            getOriginalState,\r\n            condition: (\r\n              predicate: AnyListenerPredicate<any>,\r\n              timeout?: number\r\n            ) => take(predicate, timeout).then(Boolean),\r\n            take,\r\n            delay: createDelay(internalTaskController.signal),\r\n            pause: createPause<any>(internalTaskController.signal),\r\n            extra,\r\n            signal: internalTaskController.signal,\r\n            fork: createFork(internalTaskController.signal),\r\n            unsubscribe: entry.unsubscribe,\r\n            subscribe: () => {\r\n              listenerMap.set(entry.id, entry)\r\n            },\r\n            cancelActiveListeners: () => {\r\n              entry.pending.forEach((controller, _, set) => {\r\n                if (controller !== internalTaskController) {\r\n                  abortControllerWithReason(controller, listenerCancelled)\r\n                  set.delete(controller)\r\n                }\r\n              })\r\n            },\r\n          })\r\n        )\r\n      )\r\n    } catch (listenerError) {\r\n      if (!(listenerError instanceof TaskAbortError)) {\r\n        safelyNotifyError(onError, listenerError, {\r\n          raisedBy: 'effect',\r\n        })\r\n      }\r\n    } finally {\r\n      abortControllerWithReason(internalTaskController, listenerCompleted) // Notify that the task has completed\r\n      entry.pending.delete(internalTaskController)\r\n    }\r\n  }\r\n\r\n  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap)\r\n\r\n  const middleware: ListenerMiddleware<S, D, ExtraArgument> =\r\n    (api) => (next) => (action) => {\r\n      if (addListener.match(action)) {\r\n        return startListening(action.payload)\r\n      }\r\n\r\n      if (clearAllListeners.match(action)) {\r\n        clearListenerMiddleware()\r\n        return\r\n      }\r\n\r\n      if (removeListener.match(action)) {\r\n        return stopListening(action.payload)\r\n      }\r\n\r\n      // Need to get this state _before_ the reducer processes the action\r\n      let originalState: S | typeof INTERNAL_NIL_TOKEN = api.getState()\r\n\r\n      // `getOriginalState` can only be called synchronously.\r\n      // @see https://github.com/reduxjs/redux-toolkit/discussions/1648#discussioncomment-1932820\r\n      const getOriginalState = (): S => {\r\n        if (originalState === INTERNAL_NIL_TOKEN) {\r\n          throw new Error(\r\n            `${alm}: getOriginalState can only be called synchronously`\r\n          )\r\n        }\r\n\r\n        return originalState as S\r\n      }\r\n\r\n      let result: unknown\r\n\r\n      try {\r\n        // Actually forward the action to the reducer before we handle listeners\r\n        result = next(action)\r\n\r\n        if (listenerMap.size > 0) {\r\n          let currentState = api.getState()\r\n          // Work around ESBuild+TS transpilation issue\r\n          const listenerEntries = Array.from(listenerMap.values())\r\n          for (let entry of listenerEntries) {\r\n            let runListener = false\r\n\r\n            try {\r\n              runListener = entry.predicate(action, currentState, originalState)\r\n            } catch (predicateError) {\r\n              runListener = false\r\n\r\n              safelyNotifyError(onError, predicateError, {\r\n                raisedBy: 'predicate',\r\n              })\r\n            }\r\n\r\n            if (!runListener) {\r\n              continue\r\n            }\r\n\r\n            notifyListener(entry, action, api, getOriginalState)\r\n          }\r\n        }\r\n      } finally {\r\n        // Remove `originalState` store from this scope.\r\n        originalState = INTERNAL_NIL_TOKEN\r\n      }\r\n\r\n      return result\r\n    }\r\n\r\n  return {\r\n    middleware,\r\n    startListening,\r\n    stopListening,\r\n    clearListeners: clearListenerMiddleware,\r\n  } as ListenerMiddlewareInstance<S, D, ExtraArgument>\r\n}\r\n","import { enableES5 } from 'immer'\r\nexport * from 'redux'\r\nexport {\r\n  default as createNextState,\r\n  current,\r\n  freeze,\r\n  original,\r\n  isDraft,\r\n} from 'immer'\r\nexport type { Draft } from 'immer'\r\nexport { createSelector } from 'reselect'\r\nexport type {\r\n  Selector,\r\n  OutputParametricSelector,\r\n  OutputSelector,\r\n  ParametricSelector,\r\n} from 'reselect'\r\nexport { createDraftSafeSelector } from './createDraftSafeSelector'\r\nexport type { ThunkAction, ThunkDispatch } from 'redux-thunk'\r\n\r\n// We deliberately enable Immer's ES5 support, on the grounds that\r\n// we assume RTK will be used with React Native and other Proxy-less\r\n// environments.  In addition, that's how Immer 4 behaved, and since\r\n// we want to ship this in an RTK minor, we should keep the same behavior.\r\nenableES5()\r\n\r\nexport {\r\n  // js\r\n  configureStore,\r\n} from './configureStore'\r\nexport type {\r\n  // types\r\n  ConfigureEnhancersCallback,\r\n  ConfigureStoreOptions,\r\n  EnhancedStore,\r\n} from './configureStore'\r\nexport {\r\n  // js\r\n  createAction,\r\n  getType,\r\n} from './createAction'\r\nexport type {\r\n  // types\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  ActionCreatorWithNonInferrablePayload,\r\n  ActionCreatorWithOptionalPayload,\r\n  ActionCreatorWithPayload,\r\n  ActionCreatorWithoutPayload,\r\n  ActionCreatorWithPreparedPayload,\r\n  PrepareAction,\r\n} from './createAction'\r\nexport {\r\n  // js\r\n  createReducer,\r\n} from './createReducer'\r\nexport type {\r\n  // types\r\n  Actions,\r\n  CaseReducer,\r\n  CaseReducers,\r\n} from './createReducer'\r\nexport {\r\n  // js\r\n  createSlice,\r\n} from './createSlice'\r\n\r\nexport type {\r\n  // types\r\n  CreateSliceOptions,\r\n  Slice,\r\n  CaseReducerActions,\r\n  SliceCaseReducers,\r\n  ValidateSliceCaseReducers,\r\n  CaseReducerWithPrepare,\r\n  SliceActionCreator,\r\n} from './createSlice'\r\nexport {\r\n  // js\r\n  createImmutableStateInvariantMiddleware,\r\n  isImmutableDefault,\r\n} from './immutableStateInvariantMiddleware'\r\nexport type {\r\n  // types\r\n  ImmutableStateInvariantMiddlewareOptions,\r\n} from './immutableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  createSerializableStateInvariantMiddleware,\r\n  findNonSerializableValue,\r\n  isPlain,\r\n} from './serializableStateInvariantMiddleware'\r\nexport type {\r\n  // types\r\n  SerializableStateInvariantMiddlewareOptions,\r\n} from './serializableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  getDefaultMiddleware,\r\n} from './getDefaultMiddleware'\r\nexport type {\r\n  // types\r\n  ActionReducerMapBuilder,\r\n} from './mapBuilders'\r\nexport { MiddlewareArray } from './utils'\r\n\r\nexport { createEntityAdapter } from './entities/create_adapter'\r\nexport type {\r\n  Dictionary,\r\n  EntityState,\r\n  EntityAdapter,\r\n  EntitySelectors,\r\n  EntityStateAdapter,\r\n  EntityId,\r\n  Update,\r\n  IdSelector,\r\n  Comparer,\r\n} from './entities/models'\r\n\r\nexport {\r\n  createAsyncThunk,\r\n  unwrapResult,\r\n  miniSerializeError,\r\n} from './createAsyncThunk'\r\nexport type {\r\n  AsyncThunk,\r\n  AsyncThunkOptions,\r\n  AsyncThunkAction,\r\n  AsyncThunkPayloadCreatorReturnValue,\r\n  AsyncThunkPayloadCreator,\r\n  SerializedError,\r\n} from './createAsyncThunk'\r\n\r\nexport {\r\n  // js\r\n  isAllOf,\r\n  isAnyOf,\r\n  isPending,\r\n  isRejected,\r\n  isFulfilled,\r\n  isAsyncThunkAction,\r\n  isRejectedWithValue,\r\n} from './matchers'\r\nexport type {\r\n  // types\r\n  ActionMatchingAllOf,\r\n  ActionMatchingAnyOf,\r\n} from './matchers'\r\n\r\nexport { nanoid } from './nanoid'\r\n\r\nexport { default as isPlainObject } from './isPlainObject'\r\n\r\nexport type {\r\n  ListenerEffect,\r\n  ListenerMiddleware,\r\n  ListenerEffectAPI,\r\n  ListenerMiddlewareInstance,\r\n  CreateListenerMiddlewareOptions,\r\n  ListenerErrorHandler,\r\n  TypedStartListening,\r\n  TypedAddListener,\r\n  TypedStopListening,\r\n  TypedRemoveListener,\r\n  UnsubscribeListener,\r\n  UnsubscribeListenerOptions,\r\n  ForkedTaskExecutor,\r\n  ForkedTask,\r\n  ForkedTaskAPI,\r\n  AsyncTaskExecutor,\r\n  SyncTaskExecutor,\r\n  TaskCancelled,\r\n  TaskRejected,\r\n  TaskResolved,\r\n  TaskResult,\r\n} from './listenerMiddleware/index'\r\n\r\nexport {\r\n  createListenerMiddleware,\r\n  addListener,\r\n  removeListener,\r\n  clearAllListeners,\r\n  TaskAbortError,\r\n} from './listenerMiddleware/index'\r\n","// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\n(function(definition) {\n    /* global module, define */\n    if(typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = definition();\n    } else if(typeof define === 'function' && define.amd) {\n        define([], definition);\n    } else {\n        var exports = definition();\n        window.astar = exports.astar;\n        window.Graph = exports.Graph;\n    }\n})(function() {\n\nfunction pathTo(node){\n    var curr = node,\n        path = [];\n    while(curr.parent) {\n        path.unshift(curr);\n        curr = curr.parent;\n    }\n    return path;\n}\n\nfunction getHeap() {\n    return new BinaryHeap(function(node) {\n        return node.f;\n    });\n}\n\nvar astar = {\n    /**\n    * Perform an A* Search on a graph given a start and end node.\n    * @param {Graph} graph\n    * @param {GridNode} start\n    * @param {GridNode} end\n    * @param {Object} [options]\n    * @param {bool} [options.closest] Specifies whether to return the\n               path to the closest node if the target is unreachable.\n    * @param {Function} [options.heuristic] Heuristic function (see\n    *          astar.heuristics).\n    */\n    search: function(graph, start, end, options) {\n        graph.cleanDirty();\n        options = options || {};\n        var heuristic = options.heuristic || astar.heuristics.manhattan,\n            closest = options.closest || false;\n\n        var openHeap = getHeap(),\n            closestNode = start; // set the start node to be the closest if required\n\n        start.h = heuristic(start, end);\n\n        openHeap.push(start);\n\n        while(openHeap.size() > 0) {\n\n            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n            var currentNode = openHeap.pop();\n\n            // End case -- result has been found, return the traced path.\n            if(currentNode === end) {\n                return pathTo(currentNode);\n            }\n\n            // Normal case -- move currentNode from open to closed, process each of its neighbors.\n            currentNode.closed = true;\n\n            // Find all neighbors for the current node.\n            var neighbors = graph.neighbors(currentNode);\n\n            for (var i = 0, il = neighbors.length; i < il; ++i) {\n                var neighbor = neighbors[i];\n\n                if (neighbor.closed || neighbor.isWall()) {\n                    // Not a valid node to process, skip to next neighbor.\n                    continue;\n                }\n\n                // The g score is the shortest distance from start to current node.\n                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n                var gScore = currentNode.g + neighbor.getCost(currentNode),\n                    beenVisited = neighbor.visited;\n\n                if (!beenVisited || gScore < neighbor.g) {\n\n                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                    neighbor.visited = true;\n                    neighbor.parent = currentNode;\n                    neighbor.h = neighbor.h || heuristic(neighbor, end);\n                    neighbor.g = gScore;\n                    neighbor.f = neighbor.g + neighbor.h;\n                    graph.markDirty(neighbor);\n                    if (closest) {\n                        // If the neighbour is closer than the current closestNode or if it's equally close but has\n                        // a cheaper path than the current closest node then it becomes the closest node\n                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n                            closestNode = neighbor;\n                        }\n                    }\n\n                    if (!beenVisited) {\n                        // Pushing to heap will put it in proper place based on the 'f' value.\n                        openHeap.push(neighbor);\n                    }\n                    else {\n                        // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                        openHeap.rescoreElement(neighbor);\n                    }\n                }\n            }\n        }\n\n        if (closest) {\n            return pathTo(closestNode);\n        }\n\n        // No result was found - empty array signifies failure to find path.\n        return [];\n    },\n    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n    heuristics: {\n        manhattan: function(pos0, pos1) {\n            var d1 = Math.abs(pos1.x - pos0.x);\n            var d2 = Math.abs(pos1.y - pos0.y);\n            return d1 + d2;\n        },\n        diagonal: function(pos0, pos1) {\n            var D = 1;\n            var D2 = Math.sqrt(2);\n            var d1 = Math.abs(pos1.x - pos0.x);\n            var d2 = Math.abs(pos1.y - pos0.y);\n            return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n        }\n    },\n    cleanNode:function(node){\n        node.f = 0;\n        node.g = 0;\n        node.h = 0;\n        node.visited = false;\n        node.closed = false;\n        node.parent = null;\n    }\n};\n\n/**\n* A graph memory structure\n* @param {Array} gridIn 2D array of input weights\n* @param {Object} [options]\n* @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n*/\nfunction Graph(gridIn, options) {\n    options = options || {};\n    this.nodes = [];\n    this.diagonal = !!options.diagonal;\n    this.grid = [];\n    for (var x = 0; x < gridIn.length; x++) {\n        this.grid[x] = [];\n\n        for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n            var node = new GridNode(x, y, row[y]);\n            this.grid[x][y] = node;\n            this.nodes.push(node);\n        }\n    }\n    this.init();\n}\n\nGraph.prototype.init = function() {\n    this.dirtyNodes = [];\n    for (var i = 0; i < this.nodes.length; i++) {\n        astar.cleanNode(this.nodes[i]);\n    }\n};\n\nGraph.prototype.cleanDirty = function() {\n    for (var i = 0; i < this.dirtyNodes.length; i++) {\n        astar.cleanNode(this.dirtyNodes[i]);\n    }\n    this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function(node) {\n    this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function(node) {\n    var ret = [],\n        x = node.x,\n        y = node.y,\n        grid = this.grid;\n\n    // West\n    if(grid[x-1] && grid[x-1][y]) {\n        ret.push(grid[x-1][y]);\n    }\n\n    // East\n    if(grid[x+1] && grid[x+1][y]) {\n        ret.push(grid[x+1][y]);\n    }\n\n    // South\n    if(grid[x] && grid[x][y-1]) {\n        ret.push(grid[x][y-1]);\n    }\n\n    // North\n    if(grid[x] && grid[x][y+1]) {\n        ret.push(grid[x][y+1]);\n    }\n\n    if (this.diagonal) {\n        // Southwest\n        if(grid[x-1] && grid[x-1][y-1]) {\n            ret.push(grid[x-1][y-1]);\n        }\n\n        // Southeast\n        if(grid[x+1] && grid[x+1][y-1]) {\n            ret.push(grid[x+1][y-1]);\n        }\n\n        // Northwest\n        if(grid[x-1] && grid[x-1][y+1]) {\n            ret.push(grid[x-1][y+1]);\n        }\n\n        // Northeast\n        if(grid[x+1] && grid[x+1][y+1]) {\n            ret.push(grid[x+1][y+1]);\n        }\n    }\n\n    return ret;\n};\n\nGraph.prototype.toString = function() {\n    var graphString = [],\n        nodes = this.grid, // when using grid\n        rowDebug, row, y, l;\n    for (var x = 0, len = nodes.length; x < len; x++) {\n        rowDebug = [];\n        row = nodes[x];\n        for (y = 0, l = row.length; y < l; y++) {\n            rowDebug.push(row[y].weight);\n        }\n        graphString.push(rowDebug.join(\" \"));\n    }\n    return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n    this.x = x;\n    this.y = y;\n    this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n    return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function(fromNeighbor) {\n    // Take diagonal weight into consideration.\n    if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n        return this.weight * 1.41421;\n    }\n    return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n    return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction){\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n    push: function(element) {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n\n        // Allow it to sink down.\n        this.sinkDown(this.content.length - 1);\n    },\n    pop: function() {\n        // Store the first element so we can return it later.\n        var result = this.content[0];\n        // Get the element at the end of the array.\n        var end = this.content.pop();\n        // If there are any elements left, put the end element at the\n        // start, and let it bubble up.\n        if (this.content.length > 0) {\n            this.content[0] = end;\n            this.bubbleUp(0);\n        }\n        return result;\n    },\n    remove: function(node) {\n        var i = this.content.indexOf(node);\n\n        // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n        var end = this.content.pop();\n\n        if (i !== this.content.length - 1) {\n            this.content[i] = end;\n\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\n                this.sinkDown(i);\n            }\n            else {\n                this.bubbleUp(i);\n            }\n        }\n    },\n    size: function() {\n        return this.content.length;\n    },\n    rescoreElement: function(node) {\n        this.sinkDown(this.content.indexOf(node));\n    },\n    sinkDown: function(n) {\n        // Fetch the element that has to be sunk.\n        var element = this.content[n];\n\n        // When at 0, an element can not sink any further.\n        while (n > 0) {\n\n            // Compute the parent element's index, and fetch it.\n            var parentN = ((n + 1) >> 1) - 1,\n                parent = this.content[parentN];\n            // Swap the elements if the parent is greater.\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n                this.content[parentN] = element;\n                this.content[n] = parent;\n                // Update 'n' to continue at the new position.\n                n = parentN;\n            }\n            // Found a parent that is less, no need to sink any further.\n            else {\n                break;\n            }\n        }\n    },\n    bubbleUp: function(n) {\n        // Look up the target element and its score.\n        var length = this.content.length,\n            element = this.content[n],\n            elemScore = this.scoreFunction(element);\n\n        while(true) {\n            // Compute the indices of the child elements.\n            var child2N = (n + 1) << 1,\n                child1N = child2N - 1;\n            // This is used to store the new position of the element, if any.\n            var swap = null,\n                child1Score;\n            // If the first child exists (is inside the array)...\n            if (child1N < length) {\n                // Look it up and compute its score.\n                var child1 = this.content[child1N];\n                child1Score = this.scoreFunction(child1);\n\n                // If the score is less than our element's, we need to swap.\n                if (child1Score < elemScore){\n                    swap = child1N;\n                }\n            }\n\n            // Do the same checks for the other child.\n            if (child2N < length) {\n                var child2 = this.content[child2N],\n                    child2Score = this.scoreFunction(child2);\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\n                    swap = child2N;\n                }\n            }\n\n            // If the element needs to be moved, swap it, and continue.\n            if (swap !== null) {\n                this.content[n] = this.content[swap];\n                this.content[swap] = element;\n                n = swap;\n            }\n            // Otherwise, we are done.\n            else {\n                break;\n            }\n        }\n    }\n};\n\nreturn {\n    astar: astar,\n    Graph: Graph\n};\n\n});\n","export function clone<T>(val: T): T {\n    if (Array.isArray(val)) {\n        return [...val] as any;\n    } else if (typeof val === \"object\") {\n        return Object.assign({}, val);\n    } else {\n        return val;\n    }\n}\n\nexport function loadDefaults<T, U>(args: T, defaults: U): T & U {\n    return Object.assign(defaults, args);\n}","import { CubeCoordinates } from \"./cubecoordinates\";\nimport { loadDefaults, clone } from \"./utils\";\n\nexport default class Hex<Data=any> implements CubeCoordinates {\n    constructor(public q: number = 0, public r: number = 0, public data?: Data) {\n        \n    }\n\n    get s(): number {\n        return 0 - this.q - this.r;\n    }\n\n    rotateRight(times: number = 1, _center?: CubeCoordinates) {\n        // Deal with negative and positive numbers\n        times = (times % 6 + 6) % 6;\n        const center = _center? {q: _center.q, r: _center.r} : {q: 0, r: 0};\n\n        if (center) {\n            [this.q, this.r] = [this.q - center.q, this.r - center.r];\n        }\n\n        switch(times) {\n            case 0: break;\n            case 1: [this.q, this.r] = [-this.r, -this.s]; break;\n            case 2: [this.q, this.r] = [this.s, this.q]; break;\n            case 3: [this.q, this.r] = [-this.q, -this.r]; break;\n            case 4: [this.q, this.r] = [this.r, this.s]; break;\n            case 5: [this.q, this.r] = [-this.s, -this.q]; break;\n            default: throw new TypeError(\"Hex.rotateLeft should have an integer as parameter\");\n        }\n\n        if (center) {\n            [this.q, this.r] = [this.q + center.q, this.r + center.r];    \n        }\n    }\n\n    rotateLeft(times: number = 1, center?: CubeCoordinates) {\n        this.rotateRight(-times, center);\n    }\n\n    toString() : string {\n        return `${this.q}x${this.r}`;\n    }\n\n    toJSON(): CubeCoordinates & {data?: Data} {\n        return {\n            q: this.q,\n            r: this.r,\n            s: this.s,\n            data: this.data\n        };\n    }\n\n    /**\n     * Creates an hexagon of radius r around options.center, feeding the data supplied. \n     * \n     * A radius of 0 gives a single hexagon\n     * @param radius \n     * @param options \n     */\n    static hexagon<Data>(radius: number, options?: {center?: CubeCoordinates, data?: Data[]}) : Hex<Data>[] {\n        const {center, data} = loadDefaults(options, {data: [], center: {q: 0, r: 0, s: 0}});\n        const ret: Hex<Data>[][] = [];\n        let totalLength = 0;\n        \n        for (let r = radius; r >= 0; r--) {\n            ret.push(this.ring(r, {center, data: data.slice(totalLength)}));\n            totalLength += ret[ret.length-1].length;\n        }\n\n        return ([] as Hex<Data>[]).concat(...ret);\n    }\n\n    /**\n     * Creates a ring of radius r around options.center, feeding the data supplied\n     * \n     * @param radius \n     * @param options\n     */\n    static ring<Data>(radius: number, options?: {center?: CubeCoordinates, data?: Data[]}) : Hex<Data>[] {\n        const {center, data} = loadDefaults(options, {data: [], center: {q: 0, r: 0, s: 0}});\n        const ret: Hex<Data>[] = [];\n\n        const feed: () => Data | undefined = () => ret.length < data.length ? data[ret.length] : undefined;\n\n        // flat N to NE\n        for (let [q, r] = [radius, 0]; q >= 0; q--, r++) {\n            ret.push(new this(q,r,feed()));\n        }\n        // NE to SE\n        for (let [q, r] = [-1, radius]; q >= -radius; q--) {\n            ret.push(new this(q,r,feed()));\n        }\n        // SE to S\n        for (let [q, r] = [-radius, radius-1]; r >= 0; r--) {\n            ret.push(new this(q,r,feed()));\n        }\n        // S to SW\n        for (let [q, r] = [-radius+1, -1]; r >= -radius; r--, q++) {\n            ret.push(new this(q,r,feed()));\n        }\n        // SW to NW\n        for (let [q, r] = [1, -radius]; q <= radius; q++) {\n            ret.push(new this(q,r,feed()));\n        }\n        // NW to N\n        for (let [q, r] = [radius, -radius+1]; r < 0; r++) {\n            ret.push(new this(q,r,feed()));\n        }\n\n        for (let hex of ret) {\n            hex.q += center.q;\n            hex.r += center.r;\n        }\n\n        return ret;\n    }\n\n    /**\n     * Creates a child class that extends Hex, and initializes by default\n     * with data = `defaultData`\n     * \n     * @param defaultData \n     */\n    static extend<Data>(defaultData: Data) {\n        return class ExtendedHex extends this<Data> {\n            constructor(q: number, r: number, data?: Partial<Data>) {\n                if (typeof defaultData === \"object\") {\n                    super(q, r, Object.assign({}, defaultData, data));\n                } else {\n                    super(q, r, data === undefined ? defaultData : <Data>data);\n                }\n            }\n        }\n    }\n}","import Hex from \"./src/hex\";\nimport Grid from \"./src/grid\";\nimport { CubeCoordinates } from \"./src/cubecoordinates\";\nimport { Direction } from \"./src/direction\";\n\nexport {Hex, Grid, CubeCoordinates, Direction};","export enum Direction {\n    North = 1,\n    NorthEast = 2,\n    SouthEast = 4,\n    South = 8,\n    SouthWest = 16,\n    NorthWest = 32\n}\n\nexport namespace Direction {\n    export function list() {\n        return [Direction.North, Direction.NorthEast, Direction.SouthEast,\n            Direction.South, Direction.SouthWest, Direction.NorthWest];\n    }\n\n    export const all: number = Direction.North | Direction.NorthEast | Direction.SouthEast | Direction.South | Direction.SouthWest | Direction.NorthWest;\n}","import { Direction } from \"./direction\";\n\nexport interface CubeCoordinates {\n    q: number,\n    r: number,\n    s: number\n}\n\nexport interface CubeCoordinatesPartial {\n    q: number,\n    r: number\n}\n\nexport class CubeCoordinates implements CubeCoordinates {\n    public s: number;\n    \n    constructor(public q = 0, public r = 0) {\n        this.s = -q - r;\n    }\n}\n\nexport namespace CubeCoordinates {\n    export function translated(coord: CubeCoordinatesPartial, direction: Direction, n: number = 1): CubeCoordinates {\n        const {q, r} = coord;\n        const s = -q -r;\n        // q is up, r is diagonal up right.\n        switch (direction) {\n            // +, 0\n            case Direction.North: return {r, q: q + n, s: s - n};\n            // 0, +\n            case Direction.NorthEast: return {r: r + n, q, s: s - n};\n            // -, +\n            case Direction.SouthEast: return {r: r + n, q: q - n, s};\n            // -, 0\n            case Direction.South: return {r, q: q - n, s: s + n};\n            // 0, -\n            case Direction.SouthWest: return {r: r - n, q, s: s + n};\n            // +, -\n            case Direction.NorthWest: return {r: r - n, q: q + n, s};\n            default: throw new TypeError(\"Wrong direction: \" + direction);\n        }\n    }\n\n    export function direction(coord1: CubeCoordinates, coord2: CubeCoordinates): Direction {\n        if (coord1.q < coord2.q) {\n            return coord1.r > coord2.r ? Direction.NorthWest: Direction.North;\n        } else if (coord1.q > coord2.q) {\n            return coord1.r < coord2.r ? Direction.SouthEast : Direction.South;\n        } else {\n            // coord1.q === coord2.q\n            return coord1.r < coord2.r ? Direction.NorthEast : Direction.SouthWest;\n        }\n    }\n\n    export function parse(str: string) {\n        const spl = str.split(\"x\");\n\n        const q = +spl[0];\n        const r = +spl[1];\n        const s = -q-r;\n\n        return {q, r, s};\n    }\n\n    export function distance(coord1: CubeCoordinates, coord2: CubeCoordinates) {\n        return (Math.abs(coord1.q-coord2.q) + Math.abs(coord1.r-coord2.r) + Math.abs(coord1.s-coord2.s)) / 2;\n    }\n    \n    export function toString(coord: CubeCoordinates) {\n        if (arguments.length === 0) {\n            return \"CubeCoordinates\";\n        }\n        if (!coord) {\n            return \"undefined\";\n        }\n        return `${coord.q}x${coord.r}`;\n    }\n}","import Hex from \"./hex\";\nimport { Direction } from \"./direction\";\nimport { CubeCoordinates, CubeCoordinatesPartial } from \"./cubecoordinates\";\n\nexport default class Grid<HexType extends Hex<any> = Hex<any>> {\n    private hexes: Map<string, HexType> = new Map();\n    get size(): number { return this.hexes.size; }\n\n    constructor(...hexes: HexType[]) {\n        this.push(...hexes);\n    }\n\n    /**\n     * Merge other grids into the current grid\n     *\n     * If any hex in the new grids overlap with hexes in the current grid,\n     * the older hexes are overwritten, similarly to what happens with `Object.assign`.\n     * @param grids grids to merge into the current grid\n     */\n    merge(...grids: Array<Grid<HexType>>): Grid<HexType> {\n        const [thisHexes, ...otherHexes] = [this, ...grids].map(grid => Array.from(grid.values()));\n\n        this.hexes.clear();\n        this.push(...thisHexes.concat(...otherHexes));\n\n        return this;\n    }\n\n    /**\n     * Adds a bunch of hexes to the grid\n     * @param hexes\n     */\n    push(...hexes: HexType[]) {\n        for (const hex of hexes) {\n            this.hexes.set(`${hex.q}x${hex.r}`, hex);\n        }\n    }\n\n    get(coord: CubeCoordinatesPartial): HexType | undefined {\n        return this.hexes.get(`${coord.q}x${coord.r}`);\n    }\n\n    neighbour(coord: CubeCoordinatesPartial, direction: Direction) {\n        return this.get(CubeCoordinates.translated(coord, direction));\n    }\n\n    neighbours(center: CubeCoordinatesPartial, directions: number = Direction.all): HexType[] {\n        const ret = <HexType[]> [];\n        for (const direction of Direction.list()) {\n            if (direction & directions) {\n                const hex = this.get(CubeCoordinates.translated(center, direction));\n                if ( hex ) {\n                    ret.push(hex);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    /**\n     * Get the list of hexes forming the shortest path between two hexes (included)\n     *\n     * Using A*\n     *\n     */\n    path(coord1: CubeCoordinatesPartial, coord2: CubeCoordinatesPartial): HexType[] | undefined {\n        const hex1 = this.get(coord1);\n        const hex2 = this.get(coord2);\n\n        if (!hex1 || !hex2) {\n            return undefined;\n        }\n\n        // const testPath = this.easyPath(coord1, coord2);\n        // if (testPath) {\n        //     return testPath;\n        // }\n\n        const destCoord = hex2.toString();\n\n        interface PathTo {\n            [coord: string]: HexType[];\n        }\n\n        const allPaths: PathTo = {};\n        const toExpand: {[minDist: number]: PathTo} = {};\n        let toExpandNext: HexType[][] = [];\n\n        const addPath = (path: HexType[]) => {\n            const [last] = path.slice(-1);\n\n            const minDist = CubeCoordinates.distance(last, hex2);\n            toExpand[minDist] = toExpand[minDist] || {};\n            toExpand[minDist][last.toString()] = path;\n            allPaths[last.toString()] = path;\n        };\n\n        const readyNextIteration = () => {\n            let minDistance = Number.POSITIVE_INFINITY;\n\n            for (const key of Object.keys(toExpand)) {\n                if (+key < minDistance) {\n                    minDistance = +key;\n                }\n            }\n\n            if (minDistance < Number.POSITIVE_INFINITY) {\n                toExpandNext = Object.values(toExpand[minDistance]);\n                delete toExpand[minDistance];\n            } else {\n                toExpandNext = [];\n            }\n        };\n\n        addPath([hex1]);\n        readyNextIteration();\n\n        while (!(destCoord in allPaths) && toExpandNext.length > 0) {\n            for (const path of toExpandNext) {\n                const hex = path[path.length - 1];\n\n                for (const neighbour of this.neighbours(hex)) {\n                    if (allPaths[neighbour.toString()]) {\n                        continue;\n                    }\n\n                    addPath([...path, neighbour]);\n                }\n            }\n\n            readyNextIteration();\n        }\n\n        return allPaths[destCoord];\n    }\n\n    /**\n     * Shortest path between two coordinates, stopping when obstacle\n     * @param hex1\n     * @param hex2\n     */\n    easyPath(coord1: CubeCoordinatesPartial, coord2: CubeCoordinatesPartial): HexType[] | undefined {\n        const hex1 = this.get(coord1);\n        const hex2 = this.get(coord2);\n\n        if (!hex1 || !hex2) {\n            return undefined;\n        }\n\n        const path = [hex1];\n\n        let currentHex: HexType | undefined = hex1;\n\n        while (currentHex.q !== hex2.q || currentHex.r !== hex2.r) {\n            currentHex = this.neighbour(currentHex, CubeCoordinates.direction(currentHex, hex2));\n\n            if (!currentHex) {\n                return undefined;\n            }\n\n            path.push(currentHex);\n        }\n\n        return path;\n    }\n\n    /**\n     * Distance between two hexes. -1 if not possible\n     *\n     */\n    distance(hex1: CubeCoordinatesPartial, hex2: CubeCoordinatesPartial) {\n        const path = this.path(hex1, hex2);\n\n        return (path || []).length - 1;\n    }\n\n    /**\n     * Removes a hex by its coordinates. Returns whether there\n     * was a hex removed\n     *\n     * @param q\n     * @param r\n     */\n    remove({q, r}: CubeCoordinatesPartial): boolean {\n        return this.hexes.delete(`${q}x${r}`);\n    }\n\n    /**\n     * Rotates the whole grid X times to the left, relative to center.\n     *\n     * Each rotation is 60\n     *\n     * @param times\n     * @param center The origin if not given\n     */\n    rotateLeft(times: number = 1, center?: CubeCoordinates): Grid<HexType> {\n        this.hexes.forEach(hex => hex.rotateLeft(times, center));\n        this.recalibrate();\n\n        return this;\n    }\n\n    /**\n     * Rotates the whole grid X times to the right, relative to center.\n     *\n     * Each rotation is 60\n     *\n     * @param times\n     * @param center The origin if not given\n     */\n    rotateRight(times: number = 1, center?: CubeCoordinates): Grid<HexType> {\n        this.hexes.forEach(hex => hex.rotateRight(times, center));\n        this.recalibrate();\n\n        return this;\n    }\n\n    /**\n     * Separate the hexes given into groups.\n     *\n     * Each hex in a group can travel through to other\n     * members of its group by going through only members\n     * of its group.\n     *\n     * @param hexes\n     */\n    groups(hexes: HexType[]) {\n        const hexSet = new Set(hexes);\n        const groups: Array<Set<HexType>> = [];\n\n        for (const hex of hexes) {\n            // If the hex is already in a group\n            if ((() => {\n                for (const group of groups) {\n                    if (group.has(hex)) {\n                        return true;\n                    }\n                }\n            })()) {\n                continue;\n            }\n\n            const newGroup = new Set([hex]);\n            let toExplore = new Set([hex]);\n            let nextToExplore = new Set<HexType>();\n\n            groups.push(newGroup);\n\n            while (toExplore.size > 0) {\n                for (const hex of toExplore) {\n                    for (const nb of this.neighbours(hex)) {\n                        if (newGroup.has(nb)) {\n                            continue;\n                        }\n\n                        if (!hexSet.has(nb)) {\n                            continue;\n                        }\n\n                        newGroup.add(nb);\n                        nextToExplore.add(nb);\n                    }\n                }\n\n                toExplore = nextToExplore;\n                nextToExplore = new Set();\n            }\n        }\n\n        return groups;\n    }\n\n    /**\n     * Makes sure the underlying storage of Hexes is coherent, if\n     * any of their coordinates was changed since they were added\n     */\n    recalibrate(): Grid<HexType> {\n        const array = Array.from(this.values());\n        this.hexes.clear();\n        this.push(...array);\n\n        return this;\n    }\n\n    values(): IterableIterator<HexType> {\n        return this.hexes.values();\n    }\n\n    toJSON(): HexType[] {\n        return Array.from(this.values());\n    }\n}\n","/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.axis = factory();\n  }\n}(this, function () {\n\n  'use strict';\n\n  var axis = {};\n\n  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' ');\n\n  function type() {\n    return Object.prototype.toString.call(this).slice(8, -1);\n  }\n\n  for (var i = types.length; i--;) {\n    axis['is' + types[i]] = (function (self) {\n      return function (elem) {\n        return type.call(elem) === self;\n      };\n    })(types[i]);\n  }\n\n  return axis;\n\n}));\n","import { isNumber, isObject } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n  return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n  return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n  if (!/^(N|S)?(E|W)?$/i.test(value)) {\n    throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n  }\n\n  orientation = orientation.toLowerCase()\n  value = value.toUpperCase()\n\n  if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n    throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n  }\n  if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n    throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n  }\n\n  /**\n   * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n   * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n   * and flat hexes don't have a west and east compass direction.\n   *\n   * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n   * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n   *\n   * @typedef {string} COMPASS_DIRECTION\n   *\n   * @readonly\n   * @enum {COMPASS_DIRECTION}\n   *\n   * @property {COMPASS_DIRECTION} E   east\n   * @property {COMPASS_DIRECTION} SE  southeast\n   * @property {COMPASS_DIRECTION} S   south\n   * @property {COMPASS_DIRECTION} SW  southwest\n   * @property {COMPASS_DIRECTION} W   west\n   * @property {COMPASS_DIRECTION} NW  northwest\n   * @property {COMPASS_DIRECTION} N   north\n   * @property {COMPASS_DIRECTION} NE  northeast\n   */\n  return {\n    pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n    flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 },\n  }[orientation][value]\n}\n\nexport function ensureXY(x, y) {\n  if (!isNumber(x) && !isNumber(y)) {\n    x = y = 0\n  } else if (!isNumber(x)) {\n    x = y\n  } else if (!isNumber(y)) {\n    y = x\n  }\n\n  return { x, y }\n}\n\nexport function normalizeRadiuses(size, isPointy) {\n  if (isObject(size)) {\n    if (isNumber(size.xRadius) && isNumber(size.yRadius)) {\n      return size\n    }\n\n    const { width, height } = size\n    if (isNumber(width) && isNumber(height)) {\n      return isPointy\n        ? { xRadius: width / Math.sqrt(3), yRadius: height / 2 }\n        : { xRadius: width / 2, yRadius: height / Math.sqrt(3) }\n    }\n  }\n\n  if (isNumber(size)) {\n    return { xRadius: size, yRadius: size }\n  }\n\n  throw new Error(`Invalid size: ${size}. Set it as a number or as an object containing width and height.`)\n}\n","/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\n\nexport const DIRECTION_COORDINATES = [\n  { q: 1, r: 0, s: -1 },\n  { q: 0, r: 1, s: -1 },\n  { q: -1, r: 1, s: 0 },\n  { q: -1, r: 0, s: 1 },\n  { q: 0, r: -1, s: 1 },\n  { q: 1, r: -1, s: 0 },\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n  { q: 2, r: -1, s: -1 },\n  { q: 1, r: 1, s: -2 },\n  { q: -1, r: 2, s: -1 },\n  { q: -2, r: 1, s: 1 },\n  { q: -1, r: -1, s: 2 },\n  { q: 1, r: -2, s: 1 },\n]\n\nexport const EPSILON = { q: 1e-6, r: 1e-6, s: -2e-6 }\n","import { isNumber, isString } from 'axis.js'\nimport { DIAGONAL_DIRECTION_COORDINATES, DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n  if (isNumber(keyOrPoint)) {\n    return this[keyOrPoint]\n  } else {\n    return this[this.indexOf(keyOrPoint)]\n  }\n}\n\nexport function setFactory({ isValidHex }) {\n  /**\n   * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n   *\n   * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n   * If the new hex is invalid, nothing changes.\n   *\n   * @memberof Grid#\n   * @instance\n   *\n   * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n   * @param {hex} newHex                  The replacing hex.\n   *\n   * @returns {grid}                      Itself.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n   *\n   * // replace a hex:\n   * grid.set(0, Hex(1, 1))\n   * grid                         // [ { x: 1, y: 1 } ]\n   * // the target hex can also be a point:\n   * grid.set([1, 1], Hex(2, 2))\n   * grid                         // [ { x: 2, y: 2 } ]\n   *\n   * // invalid replace values are ignored:\n   * grid.set(0, 'invalid')\n   * grid                         // [ { x: 2, y: 2 } ]\n   *\n   * // when the target hex isn't present in the grid, the replacing hex is added instead:\n   * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n   * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n   */\n  return function set(keyOrPoint, newHex) {\n    if (!isValidHex(newHex)) {\n      return this\n    }\n\n    const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n    if (index < 0) {\n      this.push(newHex)\n    } else {\n      this[index] = newHex\n    }\n\n    return this\n  }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n  const distance = firstHex.distance(lastHex)\n  const step = 1.0 / Math.max(distance, 1)\n  let hexes = []\n\n  for (let i = 0; i <= distance; i++) {\n    const hex = firstHex\n      .nudge()\n      .lerp(lastHex.nudge(), step * i)\n      .round()\n    hexes.push(this.get(hex))\n  }\n\n  return hexes\n}\n\nexport function hexesInRangeFactory({ isValidHex }) {\n  /**\n   * @memberof Grid#\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#range-coordinate|redblobgames.com}\n   *\n   * @param {hex} centerHex                   A hex to get surrounding hexes from.\n   * @param {number} [range=0]                The range (in hexes) surrounding the center hex.\n   * @param {boolean} [includeCenterHex=true] Whether to include the center hex in the result\n   *\n   * @returns {hex[]}             An array with all hexes surrounding the passed center hex.\n   *                              Only hexes that are present in the grid are returned.\n   *\n   * @throws {Error} When no valid hex is passed.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * const grid = Grid.rectangle({ width: 5, height: 5 })\n   *\n   * grid.hexesInRange(Hex(2, 2), 2)          // [\n   *                                          //    { x: 0, y: 2 },\n   *                                          //    { x: 0, y: 3 },\n   *                                          //    { x: 1, y: 4 },\n   *                                          //    ...\n   *                                          //    { x: 3, y: 0 },\n   *                                          //    { x: 3, y: 1 },\n   *                                          //    { x: 4, y: 2 }\n   *                                          // ]\n   *\n   * // only returns hexes that exist in the grid:\n   * grid.hexesInRange(Hex(0, 0), 1)          // [\n   *                                          //    { x: 0, y: 0 },\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: 1, y: 0 }\n   *                                          // ]\n   *\n   * // exclude center hex:\n   * grid.hexesInRange(Hex(2, 2), 1, false)   // [\n   *                                          //    { x: 1, y: 2 },\n   *                                          //    { x: 1, y: 3 },\n   *                                          //    { x: 1, y: 1 },\n   *                                          //    { x: 2, y: 3 },\n   *                                          //    { x: 3, y: 2 }\n   *                                          // ]\n   */\n  return function hexesInRange(centerHex, range = 0, includeCenterHex = true) {\n    if (!isValidHex(centerHex)) {\n      throw new Error(`Invalid center hex: ${centerHex}.`)\n    }\n\n    if (!this.get(centerHex)) {\n      throw new Error(`Center hex with coordinates ${centerHex} not present in grid.`)\n    }\n\n    let hexes = []\n\n    for (let q = -range; q <= range; q++) {\n      for (let r = Math.max(-range, -q - range); r <= Math.min(range, -q + range); r++) {\n        const hex = this.get(centerHex.cubeToCartesian({ q: centerHex.q + q, r: centerHex.r + r }))\n\n        if (centerHex.equals(hex) && !includeCenterHex) {\n          continue\n        }\n\n        hexes.push(hex)\n      }\n    }\n\n    return hexes.filter(Boolean)\n  }\n}\n\nexport function neighborsOfFactory({ isValidHex, signedModulo, compassToNumberDirection }) {\n  /**\n   * @memberof Grid#\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n   *\n   * @param {hex} hex\n   * A hex to get 1 or more neighbors from.\n   * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n   * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n   * @param {boolean} [diagonal=false]\n   * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n   *\n   * @returns {hex[]}\n   * An array with the neighboring hex for each queried direction or `undefined` if the hex doesn't exist in the grid.\n   *\n   * @throws {Error} When no valid hex is passed.\n   * @throws {Error} When the direction is invalid for the hex.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n   * const grid = Grid.hexagon({ radius: 1 })\n   *\n   * // all neighbors:\n   * grid.neighborsOf(Hex())          // [\n   *                                  //    { x: 1, y: 0 },\n   *                                  //    { x: 0, y: 1 },\n   *                                  //    { x: -1, y: 1 },\n   *                                  //    { x: -1, y: 0 },\n   *                                  //    { x: -1, y: -1 },\n   *                                  //    { x: 0, y: -1 },\n   *                                  // ]\n   * // specific neighbor:\n   * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n   * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n   *\n   * // multiple neighbors:\n   * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: -1, y: 1 }\n   *                                          // ]\n   *\n   * grid.neighborsOf(Hex(), [1, 2])          // [\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: -1, y: 1 }\n   *                                          // ]\n   * // diagonal neighbor:\n   * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n   *\n   * // returns undefined for hexes that aren't present in the grid:\n   * grid.neighborsOf(Hex(-1, -1), 'NW')      // [undefined]\n   */\n  return function neighborsOf(hex, directions = 'all', diagonal = false) {\n    if (!isValidHex(hex)) {\n      throw new Error(`Invalid hex: ${hex}.`)\n    }\n\n    const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n    if (directions === 'all') {\n      directions = [0, 1, 2, 3, 4, 5]\n    }\n\n    return (directions = []\n      // ensure directions is an array\n      .concat(directions)\n      .map((direction) => {\n        // todo: move this to a util, also grid/statics.js#277\n        if (isString(direction)) {\n          direction = compassToNumberDirection(direction, hex.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n          direction = signedModulo(direction, 6)\n        }\n\n        const { q, r } = coordinates[direction]\n        return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n      }))\n  }\n}\n\n/**\n * @memberof Grid#\n * @instance\n *\n * @returns {number}    The width of the grid in points/pixels.\n */\nexport function pointWidth() {\n  if (this.length === 0) {\n    return 0\n  }\n\n  // sort hexes from left to right and take the first and last\n  const { 0: mostLeft, length, [length - 1]: mostRight } = this[0].isPointy()\n    ? [...this].sort((a, b) => b.s - a.s || a.q - b.q)\n    : [...this].sort((a, b) => a.q - b.q)\n\n  return mostRight.toPoint().x - mostLeft.toPoint().x + this[0].width()\n}\n\n/**\n * @memberof Grid#\n * @instance\n *\n * @returns {number}    The heigth of the grid in points/pixels.\n */\nexport function pointHeight() {\n  if (this.length === 0) {\n    return 0\n  }\n\n  // sort hexes from top to bottom and take the first and last\n  const { 0: mostUp, length, [length - 1]: mostDown } = this[0].isPointy()\n    ? [...this].sort((a, b) => a.r - b.r)\n    : [...this].sort((a, b) => b.s - a.s || a.r - b.r)\n\n  return mostDown.toPoint().y - mostUp.toPoint().y + this[0].height()\n}\n","import { isString } from 'axis.js'\nimport { DIRECTION_COORDINATES } from '../hex/constants'\nimport { offsetFromZero } from '../utils'\n\nexport function pointToHexFactory({ Hex }) {\n  /**\n   * Converts the passed {@link point} to a hex. Internally calls {@link Hex#fromPoint}.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link Hex#fromPoint}\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 50 })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * const Point = Honeycomb.Point\n   *\n   * Grid.pointToHex(Point(120, 280))     // { x: 0, y: 3 }\n   * Grid.pointToHex(120, 280)            // { x: 0, y: 3 }\n   * Grid.pointToHex({ x: 120, y: 280 })  // { x: 0, y: 3 }\n   * Grid.pointToHex([ 120, 280 ])        // { x: 0, y: 3 }\n   */\n  return function pointToHex(pointOrX, y) {\n    return Hex().fromPoint(pointOrX, y)\n  }\n}\n\nexport function parallelogramFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.width                The width (in hexes).\n   * @param {number} options.height               The height (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex.\n   * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n   *                                              Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n   */\n  return function parallelogram({\n    width,\n    height,\n    start,\n    direction = 1,\n    /**\n     * Callback of a {@link Grid} shape method.\n     * Gets called for each hex that's about to be added to the grid.\n     *\n     * @callback onCreate\n     * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n     * @param {grid} grid   The grid (for as far as it's created).\n     * @returns {void}      Nothing.\n     */\n    onCreate = () => {},\n  }) {\n    start = Hex(start)\n    // TODO: validate direction\n    const DIRECTIONS = {\n      1: ['q', 'r', 's'],\n      3: ['r', 's', 'q'],\n      5: ['s', 'q', 'r'],\n    }\n    const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n    const grid = new Grid()\n    grid.width = width\n    grid.height = height\n    grid.start = start\n    grid.direction = direction\n\n    for (let first = 0; first < width; first++) {\n      for (let second = 0; second < height; second++) {\n        const hex = Hex({\n          [firstCoordinate]: first + start[firstCoordinate],\n          [secondCoordinate]: second + start[secondCoordinate],\n          [thirdCoordinate]: -first - second + start[thirdCoordinate],\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function triangleFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.size                 The side length (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n   * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n   *                                              Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a triangle arrangement.\n   */\n  return function triangle({ size, start, direction = 1, onCreate = () => {} }) {\n    start = Hex(start)\n    // TODO: validate direction\n    const DIRECTIONS = {\n      1: {\n        rStart: () => 0,\n        rEnd: (q) => size - q,\n      },\n      5: {\n        rStart: (q) => size - q,\n        rEnd: () => size + 1,\n      },\n    }\n    const { rStart, rEnd } = DIRECTIONS[direction]\n    const grid = new Grid()\n    grid.size = size\n    grid.start = start\n    grid.direction = direction\n\n    for (let q = 0; q < size; q++) {\n      for (let r = rStart(q); r < rEnd(q); r++) {\n        const hex = Hex({\n          q: q + start.q,\n          r: r + start.r,\n          s: -q - r + start.s,\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function hexagonFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n   */\n  return function hexagon({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    const grid = new Grid()\n    grid.radius = radius\n    grid.center = center\n\n    for (let q = -radius; q <= radius; q++) {\n      const startR = Math.max(-radius, -q - radius)\n      const endR = Math.min(radius, -q + radius)\n\n      for (let r = startR; r <= endR; r++) {\n        const hex = Hex({\n          q: q + center.q,\n          r: r + center.r,\n          s: -q - r + center.s,\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n  /**\n   * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) .\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.width                The width (in hexes).\n   * @param {number} options.height               The height (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex.\n   * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n   * The direction (from the start hex) in which to create the shape.\n   * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n   * Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n   */\n  return function rectangle({\n    width,\n    height,\n    start,\n    direction = Hex().isPointy() ? 0 : 1, // E or S\n    onCreate = () => {},\n  }) {\n    start = Hex(start)\n\n    if (isString(direction)) {\n      direction = compassToNumberDirection(direction, start.orientation)\n    }\n\n    if (direction < 0 || direction > 5) {\n      direction = signedModulo(direction, 6)\n    }\n\n    const DIRECTIONS = [\n      ['q', 'r', 's'],\n      ['r', 'q', 's'],\n      ['r', 's', 'q'],\n      ['s', 'r', 'q'],\n      ['s', 'q', 'r'],\n      ['q', 's', 'r'],\n    ]\n    const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n    const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n    const grid = new Grid()\n    grid.width = width\n    grid.height = height\n    grid.start = start\n    grid.direction = direction\n\n    for (let second = 0; second < secondStop; second++) {\n      const secondOffset = offsetFromZero(start.offset, second)\n\n      for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n        const hex = Hex({\n          [firstCoordinate]: first + start[firstCoordinate],\n          [secondCoordinate]: second + start[secondCoordinate],\n          [thirdCoordinate]: -first - second + start[thirdCoordinate],\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function ringFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a ring.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rings|redblobgames.com}\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a ring arrangement.\n   */\n  return function ring({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    const grid = new Grid()\n    grid.radius = radius\n    grid.center = center\n\n    const { q, r, s } = center\n    let hex = Hex({ q, r: r - radius, s: s + radius })\n\n    for (let i = 0; i < 6; i++) {\n      for (let j = 0; j < radius; j++) {\n        onCreate(hex, grid)\n        grid.push(hex)\n\n        const { q, r, s } = DIRECTION_COORDINATES[i]\n        hex = Hex({ q: hex.q + q, r: hex.r + r, s: hex.s + s })\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function spiralFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a spiral starting from the center outward.\n   * The result is the same as a hexagon, but the order of hexes is different.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rings-spiral|redblobgames.com}\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a spiral arrangement.\n   */\n  return function spiral({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    let grid = new Grid()\n\n    onCreate(center, grid)\n    grid.push(center)\n\n    for (let i = 1; i <= radius; i++) {\n      grid = grid.concat(this.ring({ radius: i, center, onCreate }))\n    }\n\n    grid.radius = radius\n    grid.center = center\n\n    return grid\n  }\n}\n","export function addFactory({ Point }) {\n  /**\n     * @memberof Point#\n\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n  return function add(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x + x, this.y + y)\n  }\n}\n\nexport function subtractFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The difference between the passed point's coordinates and the current point's.\n   */\n  return function subtract(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x - x, this.y - y)\n  }\n}\n\nexport function multiplyFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n   */\n  return function multiply(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x * x, this.y * y)\n  }\n}\n\nexport function divideFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The division of the current point's coordinates and the passed point's.\n   */\n  return function divide(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x / x, this.y / y)\n  }\n}\n","import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n  const prototype = {\n    add: methods.addFactory({ Point }),\n    subtract: methods.subtractFactory({ Point }),\n    multiply: methods.multiplyFactory({ Point }),\n    divide: methods.divideFactory({ Point }),\n  }\n\n  /**\n   * Factory function for creating two-dimensional points.\n   *\n   * @function Point\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}                             A point.\n   *\n   * @example\n   * const Point = Honeycomb.Point\n   *\n   * Point()                  // { x: 0, y: 0 }\n   * Point(1)                 // { x: 1, y: 1 }\n   * Point(1, 2)              // { x: 1, y: 2 }\n   *\n   * Point([])                // { x: 0, y: 0 }\n   * Point([1])               // { x: 1, y: 1 }\n   * Point([1, 2])            // { x: 1, y: 2 }\n   *\n   * Point({})                // { x: 0, y: 0 }\n   * Point({ x: 1 })          // { x: 1, y: 1 }\n   * Point({ y: 2 })          // { x: 2, y: 2 }\n   * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n   */\n  function Point(pointOrX, y) {\n    let coordinates\n    /**\n     * An object with just an `x` and a `y` property.\n     *\n     * Create your own:\n     * ```javascript\n     * const point = { x: 1, y: 2 }\n     * ```\n     *\n     * Or use the included {@link Point} factory:\n     * ```javascript\n     * const point = Honeycomb.Point(1, 2)\n     * ```\n     *\n     * @typedef {Object} point\n     * @property {number} x (horizontal) x coordinate\n     * @property {number} y (vertical) y coordinate\n     */\n\n    if (isNumber(pointOrX)) {\n      coordinates = ensureXY(pointOrX, y)\n    } else if (isArray(pointOrX)) {\n      coordinates = ensureXY(...pointOrX)\n    } else if (isObject(pointOrX)) {\n      coordinates = ensureXY(pointOrX.x, pointOrX.y)\n    } else {\n      coordinates = ensureXY(0)\n    }\n\n    return Object.assign(Object.create(prototype), coordinates)\n  }\n\n  return Point\n}\n","import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n  /**\n   * @private\n   * @param {*} value     Any value.\n   * @returns {boolean}   Whether the passed value is a valid hex.\n   */\n  static isValidHex(value) {\n    return (value || {}).__isHoneycombHex === true\n  }\n\n  /**\n   * @memberof Grid#\n   * @override\n   * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n   *\n   * @returns {TypeError} An error.\n   */\n  fill() {\n    throw new TypeError('Grid.prototype.fill is not implemented')\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n   * but searches the passed hex (which can also be a {@link point}.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point             The coordinates to search for.\n   * @param {number} [fromIndex=0]    Optional index to start searching.\n   *\n   * @returns {boolean}               Whether the hex is included in the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n   *\n   * grid.includes(Hex(0))        // true\n   * grid.includes([0, 0])        // true\n   * grid.includes(Hex(0), 1)     // false\n   * grid.includes(Hex(5, 7))     // false\n   */\n  includes(point, fromIndex = 0) {\n    return !!(this.indexOf(point, fromIndex) + 1)\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n   * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point             The coordinates to search for.\n   * @param {number} [fromIndex=0]    Optional index to start searching.\n   *                                  If negative, it is taken as the offset from the end of the grid.\n   *\n   * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0), Hex(1), Hex(0))\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 1 },\n   * //    { x: 0, y: 0 }\n   * // ]\n   *\n   * grid.indexOf(Hex(0))     // 0\n   * grid.indexOf([0, 0])     // 0\n   * grid.indexOf(Hex(0), 1)  // 2\n   * grid.indexOf(Hex(5, 7))  // -1\n   */\n  indexOf(point, fromIndex = 0) {\n    const { length } = this\n    let i = Number(fromIndex)\n\n    point = Point(point)\n    i = Math.max(i >= 0 ? i : length + i, 0)\n\n    for (i; i < length; i++) {\n      if (this[i].equals(point)) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n   * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n   *\n   * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n   * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point                 The coordinates to search for.\n   * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n   *                                      If negative, it is taken as the offset from the end of the grid.\n   *\n   * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0), Hex(1), Hex(0))\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 1 },\n   * //    { x: 0, y: 0 }\n   * // ]\n   *\n   * grid.lastIndexOf(Hex(0))     // 2\n   * grid.lastIndexOf([0, 0])     // 2\n   * grid.lastIndexOf(Hex(0), 1)  // 0\n   * grid.lastIndexOf(Hex(5, 7))  // -1\n   */\n  lastIndexOf(point, fromIndex = this.length - 1) {\n    const { length } = this\n    let i = Number(fromIndex)\n\n    point = Point(point)\n    i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n    for (i; i >= 0; i--) {\n      if (this[i].equals(point)) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n   *\n   * @returns {number}        The new length of the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   *\n   * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n   * grid.push(Hex(1))            // 2\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n   *\n   * grid.push('invalid')         // 2\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n   */\n  push(...hexes) {\n    return super.push(...hexes.filter(Grid.isValidHex))\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {number} start                        Index at which to start changing the grid.\n   * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n   * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n   *\n   * @returns {hex[]}                             A grid with the deleted hexes (if any).\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid.rectangle({ width: 2, height: 1 })\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 0 },\n   * //    { x: 0, y: 1 },\n   * //    { x: 1, y: 1 }\n   * // ]\n   *\n   * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n   *\n   * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n   *\n   * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n   * grid\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 0 },\n   * //    { x: 2, y: 2 },\n   * //    { x: 1, y: 1 }\n   * // ]\n   */\n  splice(start, deleteCount, ...hexes) {\n    // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n    // this is not according to spec: it should delete all hexes (starting from `start`)\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n    if (deleteCount == null) {\n      return super.splice(start)\n    }\n\n    return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n   *\n   * @returns {number}        The new length of the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   *\n   * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n   * grid.unshift(Hex(1))         // 2\n   * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n   *\n   * grid.unshift('invalid')      // 2\n   * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n   */\n  unshift(...hexes) {\n    return super.unshift(...hexes.filter(Grid.isValidHex))\n  }\n}\n","import { isArray, isNumber } from 'axis.js'\nimport { offsetFromZero } from '../utils'\nimport { EPSILON } from './constants'\n\nexport function setFactory({ Hex }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n   * @returns {hex}           Itself with the passed parameters merged into it.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   *\n   * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n   * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n   * hex === updatedHex                                   // true: hex is updated in-place\n   */\n  return function set(...args) {\n    return Object.assign(this, Hex(...args))\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n  return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n  return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n  let x, y\n\n  if (this.isPointy()) {\n    x = q + offsetFromZero(this.offset, r)\n    y = r\n  } else {\n    x = q\n    y = r + offsetFromZero(this.offset, q)\n  }\n\n  return { x, y }\n}\n\nexport function cartesianToCubeFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   *\n   * @todo make this a static (and instance?) method\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   * const Point = Honeycomb.Point\n   *\n   * Hex().cartesianToCube(Point(4, -2))      // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube(4, -2)             // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube({ x: 4, y: -2 })   // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube([4, -2])           // { q: 5, r: -2, s: -3 }\n   */\n  return function cartesianToCube(pointOrX, y) {\n    let x, q, r\n    ;({ x, y } = Point(pointOrX, y))\n\n    if (this.isPointy()) {\n      q = x - offsetFromZero(this.offset, y)\n      r = y\n    } else {\n      q = x\n      r = y - offsetFromZero(this.offset, x)\n    }\n\n    return { q, r, s: -q - r }\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy  orientation.\n */\nexport function isPointy() {\n  return this.orientation.toLowerCase() === 'pointy'\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat  orientation.\n */\nexport function isFlat() {\n  return this.orientation.toLowerCase() === 'flat'\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n  const { xRadius } = this.size\n  return this.isPointy() ? xRadius * Math.sqrt(3) : xRadius * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n  const { yRadius } = this.size\n  return this.isPointy() ? yRadius * 2 : yRadius * Math.sqrt(3)\n}\n\nexport function cornersFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point[]}\n   * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n   * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n   *\n   * @example\n   * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n   * const Hex1 = Honeycomb.extendHex({ size: 30 })\n   * Hex1().corners() // [\n   *                  //    { x: 51.96152422706631, y: 15 },\n   *                  //    { x: 51.96152422706631, y: 45 },\n   *                  //    { x: 25.980762113533157, y: 60 },\n   *                  //    { x: 0, y: 45 },\n   *                  //    { x: 0, y: 15 },\n   *                  //    { x: 25.980762113533157, y: 0 }\n   *                  // ]\n   *\n   * // set the origin to a hex's center\n   * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n   * Hex2().corners() // [\n   *                  //    { x: 25.980762113533157, y: -15 },\n   *                  //    { x: 25.980762113533157, y: 15 },\n   *                  //    { x: 0, y: 30 },\n   *                  //    { x: -25.980762113533157, y: 15 },\n   *                  //    { x: -25.980762113533157, y: -15 },\n   *                  //    { x: 0, y: -30 }\n   *                  // ]\n   */\n  return function corners() {\n    const width = this.width()\n    const height = this.height()\n    const { x, y } = this.origin\n\n    if (this.isPointy()) {\n      return [\n        Point(width - x, height * 0.25 - y),\n        Point(width - x, height * 0.75 - y),\n        Point(width * 0.5 - x, height - y),\n        Point(0 - x, height * 0.75 - y),\n        Point(0 - x, height * 0.25 - y),\n        Point(width * 0.5 - x, 0 - y),\n      ]\n    } else {\n      return [\n        Point(width - x, height * 0.5 - y),\n        Point(width * 0.75 - x, height - y),\n        Point(width * 0.25 - x, height - y),\n        Point(0 - x, height * 0.5 - y),\n        Point(width * 0.25 - x, 0 - y),\n        Point(width * 0.75 - x, 0 - y),\n      ]\n    }\n  }\n}\n\nexport function centerFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n   * Note that the default origin is the top left corner, so the default center is\n   * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n   *\n   * @example\n   * const Hex1 = Honeycomb.extendHex({ size: 10 })\n   * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n   *\n   * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n   * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n   */\n  return function center() {\n    const { x, y } = this.origin\n    return Point(this.width() / 2 - x, this.height() / 2 - y)\n  }\n}\n\nexport function toPointFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point} The hex's origin point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 30 })\n   * Hex().toPoint()          // { x: 0, y: 0 }\n   * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n   */\n  return function toPoint() {\n    const { q, r, size } = this\n    const { xRadius, yRadius } = size\n    let x, y\n\n    if (this.isPointy()) {\n      x = xRadius * Math.sqrt(3) * (q + r / 2)\n      y = ((yRadius * 3) / 2) * r\n    } else {\n      x = ((xRadius * 3) / 2) * q\n      y = yRadius * Math.sqrt(3) * (r + q / 2)\n    }\n\n    return Point(x, y)\n  }\n}\n\nexport function fromPointFactory({ Point, Hex }) {\n  /**\n   * Returns a hex from the passed {@link point}.\n   *\n   * @memberof Hex\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 50 })\n   * const Point = Honeycomb.Point\n   * const hex = Hex()\n   *\n   * hex.fromPoint(Point(120, 280))     // { x: 0, y: 3 }\n   * hex.fromPoint(120, 280)            // { x: 0, y: 3 }\n   * hex.fromPoint({ x: 120, y: 280 })  // { x: 0, y: 3 }\n   * hex.fromPoint([ 120, 280 ])        // { x: 0, y: 3 }\n   */\n  return function fromPoint(pointOrX, y) {\n    const { xRadius, yRadius } = this.size\n    let x, q, r\n    ;({ x, y } = Point(pointOrX, y).subtract(this.center()))\n\n    // inspired by https://github.com/gojuno/hexgrid-py\n    // and simplified by https://www.symbolab.com/solver/simplify-calculator/simplify\n    if (this.isPointy()) {\n      q = (Math.sqrt(3) * x) / (3 * xRadius) - y / (3 * yRadius)\n      r = (2 / 3) * (y / yRadius)\n    } else {\n      q = (2 / 3) * (x / xRadius)\n      r = (Math.sqrt(3) * y) / (3 * yRadius) - x / (3 * xRadius)\n    }\n\n    return Hex({ q, r, s: -q - r }).round()\n  }\n}\n\nexport function addFactory({ Hex, Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @todo Accept any number of hexes to add.\n   *\n   * @param {point} point The hex (or point) that will be added to the current.\n   * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n   *                      Any custom properties are copied.\n   */\n  return function add(point) {\n    const { x, y } = Point(point)\n    return Hex(this.x + x, this.y + y, { ...this })\n  }\n}\n\nexport function subtractFactory({ Hex, Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @todo Accept any number of hexes to subtract.\n   *\n   * @param {point} point The hex (or point) that will be subtracted from the current.\n   * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n   *                      Any custom properties are copied.\n   */\n  return function subtract(point) {\n    const { x, y } = Point(point)\n    return Hex(this.x - x, this.y - y, { ...this })\n  }\n}\n\nexport function equalsFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n   * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n   */\n  return function equals(point) {\n    if (point != null && (isArray(point) || (isNumber(point.x) && isNumber(point.y)))) {\n      const { x, y } = Point(point)\n      return this.x === x && this.y === y\n    }\n\n    return false\n  }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n  return Math.max(Math.abs(this.q - hex.q), Math.abs(this.r - hex.r), Math.abs(this.s - hex.s))\n}\n\nexport function roundFactory({ Hex }) {\n  /**\n   * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n   *\n   * @memberof Hex#\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n   *\n   * @returns {hex}   A *new* hex with rounded coordinates.\n   *                  Any custom properties are copied.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n   */\n  return function round() {\n    let { q, r, s } = this\n    let roundedQ = Math.round(q)\n    let roundedR = Math.round(r)\n    let roundedS = Math.round(s)\n    const diffQ = Math.abs(q - roundedQ)\n    const diffR = Math.abs(r - roundedR)\n    const diffS = Math.abs(s - roundedS)\n\n    if (diffQ > diffR && diffQ > diffS) {\n      roundedQ = -roundedR - roundedS\n    } else if (diffR > diffS) {\n      roundedR = -roundedQ - roundedS\n    } else {\n      roundedS = -roundedQ - roundedR\n    }\n\n    return Hex({ ...this, q: roundedQ, r: roundedR, s: roundedS })\n  }\n}\n\nexport function lerpFactory({ Hex }) {\n  /**\n   * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n   * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n   *\n   * @memberof Hex#\n   *\n   * @param   {hex} hex   The other hex (cannot be a {@link point}).\n   * @param   {number} t  A \"parameter\" between 0 and 1.\n   *\n   * @returns {hex}       A new hex (likely with floating point coordinates).\n   *                      Any custom properties are copied.\n   */\n  return function lerp(hex, t) {\n    const q = this.q * (1 - t) + hex.q * t\n    const r = this.r * (1 - t) + hex.r * t\n    return Hex({ ...this, q, r, s: -q - r })\n  }\n}\n\nexport function nudgeFactory({ Hex }) {\n  /**\n   * @memberof Hex#\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n   *\n   * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n   *                  Useful for interpolating in a consistent direction.\n   */\n  return function nudge() {\n    const { q, r, s } = EPSILON\n    return Hex({ ...this, q: this.q + q, r: this.r + r, s: this.s + s })\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n  return `${this.x},${this.y}`\n}\n","import { isArray, isNumber, isObject } from 'axis.js'\nimport * as methods from './prototype'\nimport * as statics from './statics'\n\nexport const staticMethods = {\n  thirdCoordinate: statics.thirdCoordinate,\n}\n\nexport default function extendHexFactory({ ensureXY, normalizeRadiuses, Point }) {\n  /**\n   * @function extendHex\n   *\n   * @memberof Honeycomb\n   * @static\n   *\n   * @description\n   * This function can be used to create custom hexes by extending the default Hex prototype.\n   *\n   * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n   * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n   *\n   * @todo validate orientation, origin\n   * @todo warn when properties are overriden\n   *\n   * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n   *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n   *\n   * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({\n   *     size: 50,\n   *     orientation: 'flat',\n   *     customProperty: `I'm custom `,\n   *     customMethod() {\n   *         return `${this.customProperty} and called from a custom method `\n   *     }\n   * })\n   * const hex = Hex(5, -1)\n   *\n   * hex.coordinates()    // { x: 5, y: -1 }\n   * // size is normalized to an object containing an x radius and y radius:\n   * hex.size             // { xRadius: 50, yRadius: 50 }\n   * hex.customProperty   // I'm custom \n   * hex.customMethod()   // I'm custom  and called from a custom method \n   *\n   * // every hex created with Hex() shares these properties:\n   * const hex2 = Hex(3, 0)\n   * hex2.size            // { xRadius: 50, yRadius: 50 }\n   * hex2.customProperty  // I'm custom \n   *\n   * // to set properties on individual hexes, pass them to Hex():\n   * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake ` })\n   * hex3.instanceProperty    // I'm a unique snowflake \n   */\n  return function extendHex(prototype = {}) {\n    const cartesianToCube = methods.cartesianToCubeFactory({ Point })\n    const defaultPrototype = {\n      /**\n       * Used internally for type checking\n       *\n       * @memberof Hex#\n       * @private\n       */\n      __isHoneycombHex: true,\n      /**\n       * Either  pointy or  flat. Defaults to `pointy`.\n       *\n       * @memberof Hex#\n       * @type {string}\n       * @default 'pointy'\n       */\n      orientation: 'pointy',\n      /**\n       * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n       * Can be anything the {@link Honeycomb.Point} factory accepts.\n       * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n       *\n       * @memberof Hex#\n       * @type {point}\n       * @default 0\n       */\n      origin: 0,\n      /**\n       * A hex's size that can be set as:\n       * * an object with `width` and `height`, representing the total width and height of the hex\n       * * an object with `xRadius` and `yRadius`. This can be visualized as if the hex was enclosed in an ellipse.\n       *   `xRadius` would be the distance from the center to the left or right of the ellipse (semi-major axis) and\n       *   `yRadius` would be the distance from the center to the top or bottom of the ellipse (semi-minor axis).\n       * * a number, represening the length of each side and the distance from the center to any corner of the hex\n       *   (which are the same in regular hexagons).\n       *\n       * ![Different ways to set size](docs/hex-sizes.png)\n       *\n       * When setting size with a number the hex will be regular. When setting size with an object it's possible to\n       * \"stretch\" a hex; having a (very) different width and height.\n       *\n       * Defaults to `{ xRadius: 1, yRadius: 1 }`.\n       *\n       * @memberof Hex#\n       * @type {{width: number, height: number}|{xRadius: number, yRadius: number}|number}\n       * @default { xRadius: 1, yRadius: 1 }\n       */\n      size: { xRadius: 1, yRadius: 1 },\n      /**\n       * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n       * Defaults to `-1` (odd offset).\n       * See {@link OFFSET} for details.\n       * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n       *\n       * @memberof Hex#\n       * @type {number}\n       * @default -1\n       * @see OFFSET\n       */\n      offset: -1,\n      /**\n       * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get q() {\n        return this.cartesianToCube(this).q\n      },\n      /**\n       * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get r() {\n        return this.cartesianToCube(this).r\n      },\n      /**\n       * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get s() {\n        return this.cartesianToCube(this).s\n      },\n\n      // methods:\n      add: methods.addFactory({ Hex, Point }),\n      /**\n       * Alias for {@link Hex#coordinates}.\n       * @memberof Hex#\n       * @instance\n       */\n      cartesian: methods.coordinates,\n      cartesianToCube,\n      center: methods.centerFactory({ Point }),\n      coordinates: methods.coordinates,\n      corners: methods.cornersFactory({ Point }),\n      cube: methods.cube,\n      cubeToCartesian: methods.cubeToCartesian,\n      distance: methods.distance,\n      equals: methods.equalsFactory({ Point }),\n      fromPoint: methods.fromPointFactory({ Point, Hex }),\n      height: methods.height,\n      isFlat: methods.isFlat,\n      isPointy: methods.isPointy,\n      lerp: methods.lerpFactory({ Hex }),\n      nudge: methods.nudgeFactory({ Hex }),\n      round: methods.roundFactory({ Hex }),\n      set: methods.setFactory({ Hex }),\n      subtract: methods.subtractFactory({ Hex, Point }),\n      /**\n       * Alias for {@link Hex#cubeToCartesian}.\n       * @memberof Hex#\n       * @instance\n       */\n      toCartesian: methods.cubeToCartesian,\n      /**\n       * Alias for {@link Hex#cartesianToCube}.\n       * @memberof Hex#\n       * @instance\n       */\n      toCube: cartesianToCube,\n      toPoint: methods.toPointFactory({ Point }),\n      toString: methods.toString,\n      width: methods.width,\n    }\n    const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n    finalPrototype.size = normalizeRadiuses(finalPrototype.size, finalPrototype.isPointy())\n    // ensure origin is a point\n    finalPrototype.origin = Point(finalPrototype.origin)\n\n    // the toJSON method is added here, because only here it has (easy) access to the prototype\n    Object.assign(Hex, staticMethods, { toJSON: () => prototype })\n\n    /**\n     * @function Hex\n     *\n     * @description\n     * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n     *\n     * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n     *\n     * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n     *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n     *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n     *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n     * @param {number} [xOrProps.x=]                    The x coordinate.\n     * @param {number} [xOrProps.y=]                    The y coordinate.\n     * @param {number} [y=]                             The y coordinate.\n     * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n     *\n     * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * // passing numbers:\n     * Hex()                        // { x: 0, y: 0 }\n     * Hex(1)                       // { x: 1, y: 1 }\n     * Hex(1, 2)                    // { x: 1, y: 2 }\n     *\n     * // passing an object with cartesian coordinates:\n     * Hex({})                      // { x: 0, y: 0 }\n     * Hex({ x: 1 })                // { x: 1, y: 1 }\n     * Hex({ y: 2 })                // { x: 2, y: 2 }\n     * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n     *\n     * // passing an object with cube coordinates:\n     * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n     * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n     *\n     * // passing an array:\n     * Hex([])                      // { x: 0, y: 0 }\n     * Hex([1])                     // { x: 1, y: 1 }\n     * Hex([1, 2])                  // { x: 1, y: 2 }\n     *\n     * // custom properties:\n     * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n     * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n     *\n     * // cloning a hex:\n     * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n     * const clone = Hex(someHex)   // { x: 4, y: -2 }\n     * someHex === clone            // false\n     */\n    function Hex(xOrProps, y, customProps = {}) {\n      let x\n\n      if (isObject(xOrProps)) {\n        let { q, r, s, ...rest } = xOrProps\n\n        if (isNumber(q) || isNumber(r) || isNumber(s)) {\n          const sum = q + r + s\n          // when any coordinate is undefined, sum will be NaN\n          // deal with floating point errors by allowing a maximum precision of 1e-12\n          if (Number.isNaN(sum) || sum > 1e-12) {\n            throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n          }\n\n          ;({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n        } else {\n          ;({ x, y } = xOrProps)\n        }\n\n        customProps = rest\n      } else if (isArray(xOrProps)) {\n        ;[x, y] = xOrProps\n        // ignore all arguments except xOrProps\n        customProps = {}\n      } else {\n        x = xOrProps\n      }\n\n      /**\n       * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n       *\n       * @typedef {Object} hex\n       * @property {number} x Cartesian x coordinate.\n       * @property {number} y Cartesian y coordinate.\n       */\n      return Object.assign(\n        // the prototype has to be attached here, else Grid's shape methods break \n        Object.create(finalPrototype),\n        Object.assign(customProps, ensureXY(x, y)),\n      )\n    }\n\n    return Hex\n  }\n}\n","/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n  return -firstCoordinate - secondCoordinate\n}\n","import defineGridFactory from './grid'\nimport Grid from './grid/class'\nimport extendHexFactory from './hex'\nimport PointFactory from './point'\nimport { ensureXY, normalizeRadiuses } from './utils'\n\nconst Point = PointFactory({ ensureXY })\nconst extendHex = extendHexFactory({ ensureXY, normalizeRadiuses, Point })\nconst defineGrid = defineGridFactory({ extendHex, Grid, Point })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport { extendHex, defineGrid, Point }\n","const {round, abs, random} = Math;\n\nexport function throwError(msg) {\n    console.error(msg)\n    throw msg\n}\n\nexport function deepEqual(objA, objB) {\n    const ok = Object.keys, typeOfObjA = typeof objA, typeOfObjB = typeof objB;\n    return objA && objB && typeOfObjA === 'object' && typeOfObjA === typeOfObjB ? (\n        ok(objA).length === ok(objB).length &&\n            ok(objA).every(key => deepEqual(objA[key], objB[key]))\n    ) : (objA === objB)\n}\n\nexport function roundCubeCoords(qq, rr, ss) {\n    let q = round(qq)\n    let r = round(rr)\n    let s = round(ss)\n\n    let qDiff = abs(q - qq)\n    let rDiff = abs(r - rr)\n    let sDiff = abs(s - ss)\n\n    if (qDiff > rDiff && qDiff > sDiff) {\n        q = -r - s\n    } else if (rDiff > sDiff) {\n        r = -q-s\n    } else {\n        s = -q-r\n    }\n\n    if (q === -0) q = 0\n    if (r === -0) r = 0\n    if (s === -0) s = 0\n\n    return {q, r, s}\n}\n\nexport function lerp(a, b, t) {\n    return a * (1-t) + b * t\n}\n\nexport function randNum(min, max) {\n    return round(random() * (max - min) + min)\n}\n\nconst alphabetArray = ('abcdefghijklmnopqrstuvwxyz').split('')\nexport function alphabeticalKeys(arr) {\n    const alphabetLength = alphabetArray.length\n    let keyAmt = 1\n    let j = 0\n    const obj = {}\n    for (let i = 0; i < arr.length; i++) {\n        if (i > 0 && i % alphabetLength === 0) {\n            keyAmt++\n            j = 0\n        }\n        let key = Array.from({length: keyAmt})\n            .map(() => alphabetArray[j])\n            .join('')\n        Object.assign(obj, {[key]: arr[i]})\n        j++\n    }\n    return obj\n}\nconst EPSILON = Number.EPSILON;\nfunction clamp (value, min, max) {\n    return min < max\n        ? (value < min ? min : value > max ? max : value)\n        : (value < max ? max : value > min ? min : value);\n}\nfunction inverseLerp (min, max, t) {\n    if (Math.abs(min - max) < EPSILON) return 0;\n    else return (t - min) / (max - min);\n}\n\nfunction smoothstep (min, max, t) {\n    const x = clamp(inverseLerp(min, max, t), 0, 1);\n    return x * x * (3 - 2 * x);\n}\n\nexport class Queue {\n    constructor() {\n        this.elements = {};\n        this.head = 0;\n        this.tail = 0;\n    }\n\n    enqueue(element) {\n        this.elements[this.tail] = element;\n        this.tail++;\n    }\n\n    dequeue() {\n        const item = this.elements[this.head];\n        delete this.elements[this.head];\n        this.head++;\n        return item;\n    }\n\n    peek() {\n        return this.elements[this.head];\n    }\n\n    get length() {\n        return this.tail - this.head;\n    }\n\n    get isEmpty() {\n        return this.length === 0;\n    }\n}\n\n// vector<Hex> hex_linedraw(Hex a, Hex b) {\n//     int N = hex_distance(a, b);\n//     FractionalHex a_nudge(a.q + 1e-6, a.r + 1e-6, a.s - 2e-6);\n//     FractionalHex b_nudge(b.q + 1e-6, b.r + 1e-6, b.s - 2e-6);\n//     vector<Hex> results = {};\n//     double step = 1.0 / max(N, 1);\n//     for (int i = 0; i <= N; i++) {\n//         results.push_back(\n//             hex_round(hex_lerp(a_nudge, b_nudge, step * i)));\n//     }\n//     return results;\n// }","import { isArray, isNumber } from 'axis.js'\nimport { compassToNumberDirection, signedModulo } from '../utils'\nimport * as methods from './prototype'\nimport * as statics from './statics'\n\nexport default function defineGridFactory({ extendHex, Grid, Point }) {\n  const { isValidHex } = Grid\n\n  /**\n   * @function defineGrid\n   *\n   * @memberof Honeycomb\n   * @static\n   *\n   * @description\n   * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n   *\n   * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n   *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n   *\n   * @returns {Grid}                          A Grid factory.\n   *\n   * @example\n   * // create a Grid factory that uses the default Hex Factory:\n   * const Grid = Honeycomb.defineGrid()\n   * const hex = Grid.Hex()\n   * hex.size         // { xRadius: 1, yRadius: 1 }\n   *\n   * // create your own Hex factory\n   * const CustomHex = Honeycomb.extendHex({ size: 10, custom: '' })\n   * // and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n   * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n   * const customHex = CustomGrid.Hex()\n   * customHex.size   // { xRadius: 10, yRadius: 10 }\n   * customHex.custom // \n   */\n  return function defineGrid(Hex = extendHex()) {\n    // static properties\n    Object.assign(GridFactory, {\n      /**\n       * The {@link Hex} factory the Grid factory was created with.\n       * @memberof Grid\n       * @static\n       * @function\n       */\n      // don't manually bind `this` to Hex (i.e. `Hex.call`/`Hex.apply`) anywhere in the source\n      // it could cause this:\n      // function methodThatBindsThis() {\n      //     return Hex.call(this, ...) <- `this` refers to `GridFactory`\n      // }\n      // which is caused by the following line:\n      Hex,\n\n      // methods\n      /**\n       * @memberof Grid\n       * @static\n       * @method\n       *\n       * @param {*} value     Any value.\n       * @returns {boolean}   Whether the passed value is a valid hex.\n       */\n      isValidHex,\n      pointToHex: statics.pointToHexFactory({ Point, Hex }),\n      parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n      triangle: statics.triangleFactory({ Grid, Hex }),\n      hexagon: statics.hexagonFactory({ Grid, Hex }),\n      rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }),\n      ring: statics.ringFactory({ Grid, Hex }),\n      spiral: statics.spiralFactory({ Grid, Hex }),\n    })\n\n    // prototype properties\n    Object.assign(Grid.prototype, {\n      // methods\n      get: methods.get,\n      hexesBetween: methods.hexesBetween,\n      hexesInRange: methods.hexesInRangeFactory({ isValidHex }),\n      neighborsOf: methods.neighborsOfFactory({\n        isValidHex,\n        signedModulo,\n        compassToNumberDirection,\n      }),\n      pointHeight: methods.pointHeight,\n      pointWidth: methods.pointWidth,\n      set: methods.setFactory({ isValidHex }),\n    })\n\n    /**\n     * @function Grid\n     *\n     * @description\n     * A function to create hex {@link grid}s and perform various operations on them.\n     *\n     * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n     * It can also be called with 1 or more points/hexes or an array of points/hexes to create a {@link grid} instance.\n     *\n     * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n     *\n     * @param {...point} [points] An array of points/hexes or separate arguments that are points/hexes.\n     * @returns {grid}            A grid instance containing only valid hexes.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * // the Hex factory used by the Grid to produce hexes is available as a property\n     * const Hex = Grid.Hex\n     *\n     * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     *\n     * // it also accepts points\n     * Grid({ x: 3, y: -1 }, [2, 0])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     * Grid([{ x: 3, y: -1 }, [2, 0]])  // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     *\n     * // clone a grid:\n     * const grid = Grid(Hex(), Hex(1), Hex(2))\n     * const clonedGrid = Grid(grid)      // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n     * grid === clonedGrid                // false\n     */\n    function GridFactory(...points) {\n      points = points.filter(Boolean)\n\n      if (isArray(points[0]) && (points[0].length === 0 || points[0].some((point) => !isNumber(point)))) {\n        points = points[0]\n      }\n\n      /**\n       * @typedef {Object} grid\n       * @extends Array\n       *\n       * @property {number} length    Amount of hexes in the grid.\n       */\n      return new Grid(...points.map((point) => Hex(point)))\n    }\n\n    return GridFactory\n  }\n}\n","import {roundCubeCoords, deepEqual, throwError, lerp} from './utilities.js'\n\nconst {PI, sqrt, abs, cos, sin, max, round} = Math;\n\nexport const ORIENTATION = {\n    f0: 3.0 / 2.0, f1: 0.0, f2: sqrt(3.0) / 2.0, f3: sqrt(3.0),\n    b0: 2.0 / 3.0, b1: 0.0, b2: -1.0 / 3.0, b3: sqrt(3.0) / 3.0,\n    startAngle: 0.0\n}\n\nexport const DIRECTIONS = {\n    upLeft:    hexagon(-1, 0, 1),\n    up:        hexagon(0, -1, 1),\n    upRight:   hexagon(1, -1, 0),\n    downLeft:  hexagon(-1, 1, 0),\n    down:      hexagon(0, 1, -1),\n    downRight: hexagon(1, 0, -1),\n}\n\nexport const SIZE = 40\nexport const ORIGIN = 0\nexport const LAYOUT = layout(\n    point(SIZE, SIZE),\n    point(ORIGIN, ORIGIN)\n)\n\nexport function hexagon(q, r, s) {\n    if (q + r + s !== 0)\n        throwError('q + r + s must equal 0')\n\n    return {q, r, s}\n}\n\nexport function fracHexagon(q, r, s) {\n    if (round(q + r + s) !== 0)\n        throwError('q + r + s must equal 0')\n\n    return {q, r, s}\n}\n\nexport function areHexagonsEqual(hexA, hexB) {\n    return deepEqual(hexA, hexB)\n}\n\nexport function addHexagons(hexA, hexB)  {\n    return hexagon(\n        hexA.q + hexB.q,\n        hexA.r + hexB.r,\n        hexA.s + hexB.s\n   )\n}\n\nexport function subtractHexagons(hexA, hexB)  {\n    return hexagon(\n        hexA.q - hexB.q,\n        hexA.r - hexB.r,\n        hexA.s - hexB.s\n   )\n}\n\nexport function multiplyHexagons(hex, multiplyBy)  {\n    return hexagon(\n        hex.q * multiplyBy,\n        hex.r * multiplyBy,\n        hex.s * multiplyBy\n   )\n}\n\nexport function lengthOfHexagon(hex) {\n    return (abs(hex.q) + abs(hex.r) + abs(hex.s)) / 2\n}\n\nexport function distanceBetweenHexagons(hexA, hexB) {\n    return lengthOfHexagon(subtractHexagons(hexA, hexB))\n}\n\nexport function hexagonNeighbor(hex, direction) {\n    return addHexagons(hex, direction)\n}\n\nexport function getAllNeighbors(hex) {\n    return Object.keys(DIRECTIONS).map(key => {\n        return hexagonNeighbor(hex, DIRECTIONS[key])\n    })\n}\n\nexport function point(x, y) {\n    return {x, y}\n}\n\nexport function layout(size, origin) {\n    return {\n        size: point(size.x, size.y),\n        origin: point(origin.x, origin.y)\n    }\n}\n\nexport function convertHexToPixel(hex) {\n    const M = ORIENTATION\n    const x = ((M.f0 * hex.q) + (M.f1 * hex.r)) * LAYOUT.size.x\n    const y = ((M.f2 * hex.q) + (M.f3 * hex.r)) * LAYOUT.size.y\n    return point(x + LAYOUT.origin.x, y + LAYOUT.origin.y)\n}\n\nexport function convertPixelToHex(pixelPoint) {\n    const M = ORIENTATION\n    const pt = point(\n        (pixelPoint.x - LAYOUT.origin.x) / LAYOUT.size.x,\n        (pixelPoint.y - LAYOUT.origin.y) / LAYOUT.size.y,\n    )\n    const q = M.b0 * pt.x + M.b1 * pt.y;\n    const r = M.b2 * pt.x + M.b3 * pt.y;\n    const roundedHexCoords = roundCubeCoords(q, r, -q - r)\n    return hexagon(\n        roundedHexCoords.q,\n        roundedHexCoords.r,\n        roundedHexCoords.s\n    )\n}\n\nexport function getCornerOffset(corner) {\n    const size = LAYOUT.size\n    const angle = 2.0 * PI * (ORIENTATION.startAngle + corner) / 6\n    return point(size.x * cos(angle), size.y * sin(angle))\n}\n\nexport function hexCorners(hex) {\n    const corners = []\n    const center = convertHexToPixel(hex)\n    for (let i = 0; i < 6; i++) {\n        const offset = getCornerOffset(i)\n        corners.push(point(center.x + offset.x, center.y + offset.y))\n    }\n    return corners\n}\n\nexport function roundHex(fracHex) {\n    const {q, r, s} = roundCubeCoords(fracHex.q, fracHex.r, fracHex.s)\n    return hexagon(q, r, s)\n}\n\nexport function hexLerp(a, b, t) {\n    return roundHex(\n        fracHexagon(\n            lerp(a.q, b.q, t),\n            lerp(a.r, b.r, t),\n            lerp(a.s, b.s, t)\n        )\n    )\n}\n\nexport function hexLine(hexA, hexB) {\n    const N = distanceBetweenHexagons(hexA, hexB)\n    const step = 1.0 / max(N, 1)\n\n    let results = []\n    for (let i = 0; i <= N; i++) {\n        results.push(hexLerp(hexA, hexB, i * step))\n    }\n\n    return results\n}\n\nexport function direction(coord1, coord2) {\n    if (coord1.q < coord2.q) {\n        return coord1.r > coord2.r ? DIRECTIONS.upLeft: DIRECTIONS.up;\n    } else if (coord1.q > coord2.q) {\n        return coord1.r < coord2.r ? DIRECTIONS.downRight : DIRECTIONS.down;\n    } else {\n        return coord1.r < coord2.r ? DIRECTIONS.upRight : DIRECTIONS.downLeft;\n    }\n}","import {\n    areHexagonsEqual,\n    convertHexToPixel,\n    convertPixelToHex, DIRECTIONS,\n    getAllNeighbors,\n    hexagon, hexagonNeighbor,\n    hexCorners,\n    point\n} from \"./hexagons.js\";\nimport {alphabeticalKeys, deepEqual, randNum} from \"./utilities.js\";\nimport {Grid} from \"hexagrid\";\n\nconst {min, max} = Math\n\nexport function tile(\n    hex = hexagon(0, 0, 0),\n    isTraversable = true,\n) {\n    const hexTile = hexagon(hex.q, hex.r, hex.s)\n    return {\n        index: 0,\n        cubeCoords: hexTile,\n        screenCoords: convertHexToPixel(hexTile),\n        isTraversable: isTraversable,\n        corners: hexCorners(hexTile),\n        neighborIndexes: getAllNeighbors(hexTile),\n        weight: 1,\n        occupants: 'none',\n        color: 'rgba(42, 160, 216, .5)',\n    }\n}\n\nexport function getNearestHexTile(x, y) {\n    return tile(convertPixelToHex(point(x, y)))\n}\n\nexport function hexShapedMap(radius) {\n    let map = []\n    for (let q = -radius; q <= radius; q++) {\n        let r1 = max(-radius, -q - radius);\n        let r2 = min(radius, -q + radius);\n        for (let r = r1; r <= r2; r++) {\n            map.push(tile(hexagon(q, r, -q - r)));\n        }\n    }\n    return map\n}\n\nexport function tileMap(radius = 6) {\n    const hexMap = randomizeTraversableHexes(\n        hexShapedMap(radius),\n        radius * 4\n    )\n    let map = []\n    for (let i = 0; i < hexMap.length; i++) {\n        const tile = hexMap[i]\n        tile.index = i\n        tile.neighborIndexes = tile.neighborIndexes\n            .map(neighbor => hexMap.findIndex(hex => areHexagonsEqual(hex.cubeCoords, neighbor))).filter(nIndex => nIndex !== -1)\n        map.push(tile)\n    }\n    return map\n}\n\nexport function gridGraph(tileMap) {\n    let obj = {}\n    for (let i = 0; i < tileMap.length; i++) {\n        const cubeCoords = JSON.stringify(tileMap[i].cubeCoords)\n        Object.assign(obj, {[cubeCoords]: tileMap[i].neighborIndexes.map(n => tileMap[n].cubeCoords)})\n    }\n    return obj\n}\n\nexport function mapGraph(tileMap = tileMap(6)) {\n    return tileMap\n        .map(tile => tile.neighborIndexes.filter(t => t !== -1))\n}\n\nexport function mapGraphWithWeight(tileMap) {\n    return tileMap\n        .map(tile => tile.neighborIndexes.filter(t => t !== -1).map(nIndex => ({neighbor: nIndex, weight: tileMap[nIndex].weight})))\n}\n\nexport function selectNearestHexTile(map, {x, y}) {\n    const nearestHexTile = getNearestHexTile(x, y)\n    const index = map.findIndex(item => areHexagonsEqual(item.cubeCoords, nearestHexTile.cubeCoords))\n    if (index === -1)\n        return null\n    return map[index]\n}\n\nexport function indexOfNearestTile(map, {x, y}) {\n    const nearestHexTile = getNearestHexTile(x, y)\n    const index = map.findIndex(item => areHexagonsEqual(item.cubeCoords, nearestHexTile.cubeCoords))\n    if (index === -1)\n        return null\n    return index\n}\n\nexport function randomizeTraversableHexes(hexTileMap, numOfTiles = 20) {\n    const map = hexTileMap\n    const max = map.length - 1\n    const min = 1\n    Array.from({length: numOfTiles}).forEach(() => {\n        const num = randNum(min, max)\n        const randHex = map[num]\n        randHex.isTraversable = !randHex.isTraversable\n    })\n    return map\n}\n\n","module.exports = require('./src/PathFinding');\r\n","import astar from 'javascript-astar'\nimport {Grid} from 'hexagrid'\nimport { defineGrid } from 'honeycomb-grid'\n\n// import {Grid,Engine} from \"hexapi\";\nimport {createSlice, current} from '@reduxjs/toolkit'\nimport {\n    generateMapWithGraph, gridGraph,\n    hexShapedMap, indexOfNearestTile, mapGraph,\n    selectNearestHexTile,\n    tile, tileMap\n} from \"../../lib/map.js\"\nimport {addHexagons, distanceBetweenHexagons, hexagon, hexLine, point, subtractHexagons} from \"../../lib/hexagons.js\"\nimport {deepEqual, randNum, roundCubeCoords} from \"../../lib/utilities.js\";\nimport {\n    aStar,\n    breadthFirstSearch,\n    easyPath,\n    findPath,\n    path, reconstructedPath,\n    reconstructPath,\n    returnShortestPath, searchPath\n} from \"../../lib/pathFinding.js\";\nimport PF from \"pathfinding\";\n\nconst gameSlice = createSlice({\n    name: 'game',\n\n    initialState: {\n        player: {\n            tileIndex: 0,\n            location: point(0, 0),\n            health: 3,\n            power: 100,\n            credits: 0\n        },\n        enemyTypes: {\n            grunt: {\n                tileIndex: 0,\n                location: point(0, 0),\n                health: 1,\n                drops: {\n                    credits: 10,\n                }\n            }\n        },\n        enemies: [],\n        map: [],\n        graph: [],\n        selectedHex: tile(hexagon(0, 0, 0)),\n        turns: [],\n    },\n\n    reducers: {\n        setupGame: (state, action) => {\n            const radius = action.payload.radius\n            const numOfEnemies = action.payload.numOfEnemies\n            const map = tileMap(radius)\n            const graph = mapGraph(map)\n\n            const playerTile = indexOfTraversableTile(map)\n            map[playerTile].occupants = 'player'\n            map[playerTile].neighborIndexes.forEach(n => map[n].color = 'rgba(42, 160, 216, .9)')\n            state.player.location = map[playerTile].screenCoords\n            state.player.tileIndex = playerTile\n\n            state.enemies = Array.from({length: numOfEnemies}, () => {\n                const enemyTile = indexOfTraversableTile(map)\n                let enemy = {...state.enemyTypes.grunt}\n                enemy.location = map[enemyTile].screenCoords\n                map[enemyTile].occupants = 'enemy'\n                return enemy\n            })\n\n            state.turns.push({\n                map: map,\n                lastTileIndex: playerTile,\n                player: state.player,\n                enemies: state.enemies\n            })\n\n            state.map = map\n            state.graph = graph\n        },\n\n        movePlayer: (state, action) => {\n            const map = state.map\n            const pos = action.payload\n            const nearestTile = selectNearestHexTile(map, pos)\n            const lastTurn = state.turns[state.turns.length - 1]\n\n            if (nearestTile === null || nearestTile.isTraversable === false) return\n\n            // console.log(state.player.tileIndex)\n            // console.log(state.player.tileIndex, nearestTile.index)\n            // const path = findPath(state.graph, start, end)\n            // const gridGraph = gridGraph(map)\n            // console.log(state.graph.path(map[start].cubeCoords, map[end].cubeCoords))\n\n            // let myGrid = Grid({hexSize: 30, type: 'flat', cols: '12', rows: '12'});\n            // Grid.map = map.map(hex => hex.screenCoords)\n            // let thePath = myGrid.pathTo(map[start].screenCoords, map[end].screenCoords);\n            // console.log(thePath)\n            // console.log(astar)\n            // var graphDiagonal = new astar.Graph(state.graph, { diagonal: true });\n            // var start = graphDiagonal.grid[0][0];\n            // var end = graphDiagonal.grid[1][2];\n            // var resultWithDiagonals = astar.search(graphDiagonal, start, end, { heuristic: astar.heuristics.diagonal });\n            // console.log(resultWithDiagonals)\n            // var matrix = state.graph;\n            // var grid = new PF.Grid(matrix);\n            // var finder = new PF.AStarFinder();\n            // var path = finder.findPath(start, start, end, end, grid);\n            // console.log(path)\n            // const path = findPath(state.graph, start, end)\n            // const path = reconstructPath(findPath(state.graph, start, end), start, end)\n            // // console.log(path)\n            // map[nearestTile].neighbors.forEach(tileIndex => {\n            //     map[tileIndex].color = 'black'\n            // })\n\n\n\n            const start = state.player.tileIndex\n            const end = nearestTile.index\n            const search = searchPath(state.graph, start, end)\n            // const path = findPath(search, start, end)\n\n            console.log('start: ', start)\n            console.log('end: ', end)\n            console.log('search: ', search)\n            // console.log('path: ', path)\n            // console.log(distanceBetweenHexagons(map[state.player.tileIndex].cubeCoords,map[nearestTile.index].cubeCoords))\n            // console.log(hexLine(start, end))\n\n            map[lastTurn.lastTileIndex].neighborIndexes.forEach(n => map[n].color = 'rgba(42, 160, 216, .5)')\n            map[nearestTile.index].neighborIndexes.forEach(n => map[n].color = 'rgba(42, 160, 216, .9)')\n            state.turns.push({\n                map: map,\n                lastTileIndex: nearestTile.index,\n                player: state.player,\n                enemies: state.enemies\n            })\n\n            state.player.tileIndex = nearestTile.index\n            state.player.location = nearestTile.screenCoords\n        }\n    }\n})\n\nfunction indexOfTraversableTile(map) {\n    let magicNum = randNum(0, map.length - 1)\n    let tile = map[magicNum]\n\n    while (!tile.isTraversable) {\n        const rando = randNum(0, map.length - 1)\n        tile = map[rando]\n        magicNum = rando\n    }\n    return magicNum\n}\n\nexport const {\n    setupGame,\n    movePlayer,\n} = gameSlice.actions\n\nexport default gameSlice.reducer","import {addHexagons, convertHexToPixel, direction, distanceBetweenHexagons} from \"./hexagons.js\";\nimport {Queue} from \"./utilities.js\";\n\nexport function searchPath(graph, start, goal) {\n    let cameFrom = [start]\n    let frontier = new Queue()\n    frontier.enqueue(start)\n\n    while (!frontier.isEmpty) {\n        const current = frontier.dequeue()\n\n        if (current === goal) break\n\n        graph[current].forEach(next => {\n            if (!cameFrom.includes(next)) {\n                frontier.enqueue(next)\n                cameFrom.push(next)\n            }\n        })\n    }\n    return cameFrom\n}\n\nexport function findPath(cameFrom, start, goal) {\n    let current = goal\n    let path = []\n    while (current !== start) {\n        path.push(current)\n        current = cameFrom[cameFrom.indexOf(current)]\n    }\n    return path\n}\n\nfunction prepend(value, array) {\n    let newArray = array.slice();\n    newArray.unshift(value);\n    return newArray;\n}\nfunction breadthFirstSearch(start) {\n    /* see https://www.redblobgames.com/pathfinding/a-star/introduction.html */\n    let cost_so_far = {}; cost_so_far[start] = 0;\n    let came_from = {}; came_from[start] = null;\n    let fringes = [[start]];\n    for (let k = 0; fringes[k].length > 0; k++) {\n        fringes[k+1] = [];\n        for (let hex of fringes[k]) {\n            for (let dir = 0; dir < 6; dir++) {\n                let neighbor = hex.neighbor(dir);\n                if (cost_so_far[neighbor] === undefined) {\n                    cost_so_far[neighbor] = k+1;\n                    came_from[neighbor] = hex;\n                    fringes[k+1].push(neighbor);\n                }\n            }\n        }\n    }\n    return {cost_so_far, came_from};\n}\n\nexport function reconstructedPath(map, cameFrom) {\n    let path = [];\n    let d = [];\n    cameFrom.forEach(hex => {\n        const {x, y} = convertHexToPixel(map[hex].cubeCoords);\n        path.push(map[hex]);\n        d.push(d.length === 0? 'M' : 'L', x, y);\n    })\n    path.toString = () => d.join(\" \");\n    return path;\n}\nexport function returnShortestPath(graph, start, end) {\n    let queue = [{vertex: start, path: [start]}]\n    let visited = []\n\n    while (queue.length > 0) {\n        const {vertex, path} = queue.shift()\n        visited.push(vertex)\n        graph.forEach((node, i) => {\n            if (i === end) {\n                path.push(end)\n                return\n            }\n\n            if (visited.includes({vertex: i, path: node})) {\n                queue = prepend(node, queue)\n            }\n        })\n    }\n\n    return queue\n}\n//\n// function breadthFirstSearch(start, end) {\n//     let visited = []\n//     let fringes = [[start]];\n//     while (!fringes.includes(end)) {\n//         fringes.push([]);\n//         for (let hex of fringes[k]) {\n//             // for (let dir = 0; dir < 6; dir++) {\n//             hex.neighbors.forEach(neighbor => {\n//                 if (!visited.includes(neighbor)) {\n//                     fringes[k+1].push(neighbor);\n//                 }\n//             })\n//             // }\n//         }\n//     }\n//     return visited;\n// }\n\nfunction breadthFirstSearch(graph, start, end) {\n    let reached = [start]\n    let frontier = new Queue();\n    frontier.enqueue(start)\n    while (frontier.length > 0) {\n        const current = frontier.dequeue()\n    }\n}\n\n// function hex_reachable(start, movement) {\n//\n//     fringes.push([start])\n//     for each 1 < k  movement) {}\n//         fringes.append([])\n//         for each hex in fringes[k-1]:\n//             for each 0  dir < 6:\n//                 var neighbor = hex_neighbor(hex, dir)\n//                 if neighbor not in visited and not blocked:\n//                     add neighbor to visited\n//                     fringes[k].append(neighbor)\n//\n//     return visited\n// }\n// add start to visited\n//\n// for each 1 < k  movement:\n//     fringes.append([])\n// for each hex in fringes[k-1]:\n// for each 0  dir < 6:\n// var neighbor = hex_neighbor(hex, dir)\n// if neighbor not in visited and not blocked:\n//     add neighbor to visited\n// fringes[k].append(neighbor)\n//\n// return visited\n//\n// queue = [(start,[start])]\n// visited = set()\n//\n// while queue:\n// vertex, path = queue.pop(0)\n// visited.add(vertex)\n// for node in graph[vertex]:\n// if node == end:\n// return path + [end]\n// else:\n// if node not in visited:\n// visited.add(node)\n// queue.append((node, path + [node]))\n//\n// export function reconstructPath(cameFrom, start, goal) {\n//     // console.log(cameFrom, goal)\n//     let current = goal\n//     let path = []\n//     let i = 0\n//     while (cameFrom.length - 1 !== i && current[i] !== start) {\n//         // console.log(current, start, i)\n//         path.push(current)\n//         current = cameFrom[i]\n//         i++\n//     }\n//     path.push(start)\n//     console.log(path)\n//     return path\n// }\n\n\nexport function findPathD(graph, start, goal) {\n    let frontier = [{neighbor: start.neighbor}]\n    let cameFrom = [start]\n    let costSoFar = [{neighbor: start.neighbor, weight: 0}]\n\n    let i = 0\n    while (frontier.length > 0) {\n        const current = frontier[0]\n        frontier.shift()\n\n        if (current === goal) break\n\n        graph[current].forEach(next => {\n            console.log(current(next))\n            const newCost = costSoFar[current.weight] + graph[current].weight\n            if (!costSoFar.includes(next.weight) || newCost < costSoFar.weight) {\n                costSoFar.push({neighbor: next.neighbor, weight: newCost})\n                frontier.push({neighbor: next.neighbor, weight: newCost})\n                cameFrom.push({neighbor: next.neighbor, weight: current.weight})\n            }\n        })\n    }\n    return cameFrom\n}\n\n\nexport function path(coord1, coord2) {\n    const hex1 = coord1\n    const hex2 = coord2\n\n    if (!hex1 || !hex2) {\n        return undefined;\n    }\n\n    // const testPath = this.easyPath(coord1, coord2);\n    // if (testPath) {\n    //     return testPath;\n    // }\n\n    const destCoord = hex2.toString();\n\n    const allPaths = {};\n    const toExpand = {};\n    let toExpandNext= [];\n\n    const addPath = (path) => {\n        const [last] = path.slice(-1);\n\n        const minDist = distanceBetweenHexagons(last, hex2);\n        toExpand[minDist] = toExpand[minDist] || {};\n        toExpand[minDist][last.toString()] = path;\n        allPaths[last.toString()] = path;\n    };\n\n    const readyNextIteration = () => {\n        let minDistance = Number.POSITIVE_INFINITY;\n\n        for (const key of Object.keys(toExpand)) {\n            if (+key < minDistance) {\n                minDistance = +key;\n            }\n        }\n\n        if (minDistance < Number.POSITIVE_INFINITY) {\n            toExpandNext = Object.values(toExpand[minDistance]);\n            delete toExpand[minDistance];\n        } else {\n            toExpandNext = [];\n        }\n    };\n\n    addPath([hex1]);\n    readyNextIteration();\n\n    while (!(destCoord in allPaths) && toExpandNext.length > 0) {\n        for (const path of toExpandNext) {\n            const hex = path[path.length - 1];\n\n            for (const neighbour of this.neighbours(hex)) {\n                if (allPaths[neighbour.toString()]) {\n                    continue;\n                }\n\n                addPath([...path, neighbour]);\n            }\n        }\n\n        readyNextIteration();\n    }\n\n    return allPaths[destCoord];\n}\n\nexport function easyPath(coord1, coord2) {\n    const hex1 = coord1;\n    const hex2 = coord2;\n\n    if (!hex1 || !hex2) {\n        return undefined;\n    }\n\n    const path = [hex1];\n\n    let currentHex = hex1\n\n    while (currentHex.q !== hex2.q || currentHex.r !== hex2.r) {\n        currentHex = addHexagons(hex1, hex2)\n\n        if (!currentHex) {\n            return undefined;\n        }\n\n        path.push(currentHex);\n    }\n\n    return path;\n}\n\n\n/**\n * Finds the shortest distance between two nodes using the A-star (A*) algorithm\n * @param graph an adjacency-matrix-representation of the graph where (x,y) is the weight of the edge or 0 if there is no edge.\n * @param heuristic an estimation of distance from node x to y that is guaranteed to be lower than the actual distance. E.g. straight-line distance\n * @param start the node to start from.\n * @param goal the node we're searching for\n * @return The shortest distance to the goal node. Can be easily modified to return the path.\n */\n\nexport function aStar(graph, start, goal) {\n\n\n    //This contains the distances from the start node to all other nodes\n    let distances = [];\n    //Initializing with a distance of \"Infinity\"\n    for (let i = 0; i < graph.length; i++) distances[i] = Number.MAX_VALUE;\n    //The distance from the start node to itself is of course 0\n    distances[start] = 0;\n\n    //This contains the priorities with which to visit the nodes, calculated using the heuristic.\n    let priorities = [];\n    //Initializing with a priority of \"Infinity\"\n    for (let i = 0; i < graph.length; i++) priorities[i] = Number.MAX_VALUE;\n    //start node has a priority equal to straight line distance to goal. It will be the first to be expanded.\n    priorities[start] = heuristic(start, goal);\n\n    //This contains whether a node was already visited\n    let visited = [];\n\n    //While there are nodes left to visit...\n    while (true) {\n\n        // ... find the node with the currently lowest priority...\n        let lowestPriority = Number.MAX_VALUE;\n        let lowestPriorityIndex = -1;\n        for (let i = 0; i < priorities.length; i++) {\n            //... by going through all nodes that haven't been visited yet\n            if (priorities[i] < lowestPriority && !visited[i]) {\n                lowestPriority = priorities[i];\n                lowestPriorityIndex = i;\n                console.log(lowestPriorityIndex)\n            }\n        }\n\n        if (lowestPriorityIndex === -1) {\n            // There was no node not yet visited --> Node not found\n            return -1;\n        } else if (lowestPriorityIndex === goal) {\n            // Goal node found\n            // console.log(\"Goal node found!\");\n            return distances[lowestPriorityIndex];\n        }\n\n        // console.log(\"Visiting node \" + lowestPriorityIndex + \" with currently lowest priority of \" + lowestPriority);\n\n        //...then, for all neighboring nodes that haven't been visited yet....\n        for (let i = 0; i < graph[lowestPriorityIndex].length; i++) {\n            if (graph[lowestPriorityIndex][i] !== 0 && !visited[i]) {\n                //...if the path over this edge is shorter...\n                if (distances[lowestPriorityIndex] + graph[lowestPriorityIndex][i] < distances[i]) {\n                    //...save this path as new shortest path\n                    distances[i] = distances[lowestPriorityIndex] + graph[lowestPriorityIndex][i];\n                    //...and set the priority with which we should continue with this node\n                    priorities[i] = distances[i] + heuristic[i][goal];\n                    // console.log(\"Updating distance of node \" + i + \" to \" + distances[i] + \" and priority to \" + priorities[i]);\n                }\n            }\n        }\n\n        // Lastly, note that we are finished with this node.\n        visited[lowestPriorityIndex] = true;\n        //console.log(\"Visited nodes: \" + visited);\n        //console.log(\"Currently lowest distances: \" + distances);\n\n    }\n}\n\nfunction heuristic(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y)\n}","import {configureStore} from '@reduxjs/toolkit'\nimport gameSlice from \"./slices/gameSlice.js\";\n\nconst store = configureStore({\n    reducer: {\n        game: gameSlice,\n    },\n})\n\nexport default store","export function getMousePos(ctx, event) {\n    const canvas = ctx.canvas\n    const rect = canvas.getBoundingClientRect()\n    const x = event.clientX - rect.left\n    const y = event.clientY - rect.top\n\n    // needed to account for `ctx.translate(root.width * 0.5, root.height * 0.5)`\n    const transform = ctx.getTransform();\n    const invMat = transform.invertSelf();\n\n    return {\n        x: x * invMat.a + y * invMat.c + invMat.e,\n        y: x * invMat.b + y * invMat.d + invMat.f\n    };\n}\n\nexport function drawCircle(\n    ctx,\n    x = 0,\n    y = 0,\n    color = 'black',\n    radius = 20,\n    strokeWidth = 0\n) {\n    ctx.beginPath()\n    ctx.arc(x, y, radius, 0, 2 * Math.PI, false)\n    ctx.fillStyle = color\n    ctx.fill()\n    ctx.lineWidth = strokeWidth\n    ctx.strokeStyle = color\n    ctx.stroke()\n    ctx.closePath()\n}\n","import store from \"./modules/state/store.js\"\nimport {generateMap, setupGame, spawnEnemies, spawnPlayer} from \"./modules/state/slices/gameSlice.js\";\nimport {getMousePos} from \"./modules/lib/canvasUtilites.js\"\nimport {movePlayer} from \"./modules/state/slices/gameSlice.js\";\nimport {point} from \"./modules/lib/hexagons.js\";\nimport {inverseLerp, lerp, smoothstep} from \"./modules/lib/utilities.js\";\nimport Map from './modules/components/Map.js'\nimport Player from \"./modules/components/Player.js\";\nimport Enemy from \"./modules/components/Enemy.js\";\n\nconst root = document.getElementById(\"game\")\nconst ctx = root.getContext(\"2d\")\nlet animFrame = null\n//\n// store.dispatch(generateMap(6))\n// store.dispatch(spawnPlayer())\n// store.dispatch(spawnEnemies(4))\n\nconst state = store.getState()\nlet {x, y} = state.game.player.location\n\nstore.dispatch(setupGame({radius: 6, numOfEnemies: 4}))\nrender()\nfunction render() {\n    // animFrame = requestAnimationFrame(render);\n    cleanup()\n    const state = store.getState()\n    const playerLocation = state.game.player.location\n\n    // x = lerp(x, playerLocation.x, 0.1)\n    // y = lerp(y, playerLocation.y, 0.1)\n\n    Map(ctx, state.game.map)\n    state.game.enemies.forEach(enemy => {\n        Enemy(ctx, point(enemy.location.x, enemy.location.y))\n    })\n    Player(ctx, point(playerLocation.x, playerLocation.y))\n}\n\nstore.subscribe(() => {\n    cancelAnimationFrame(animFrame)\n    render()\n})\n\nwindow.addEventListener('resize', render)\nroot.addEventListener('click', event => {\n    const {x, y} = getMousePos(ctx, event)\n    store.dispatch(movePlayer(point(x, y)))\n})\n\nfunction cleanup() {\n    root.width = window.innerWidth\n    root.height = window.innerHeight\n    ctx.translate(root.width * 0.5, root.height * 0.5)\n    ctx.clearRect(0, 0, root.width, root.height)\n}\n\n//to round to n decimal places\n//to round to n decimal places\n// function round(num, places = 8) {\n//     var multiplier = Math.pow(10, places);\n//     return Math.round(num * multiplier) / multiplier;\n// }\n","function drawHexagon(ctx, hex) {\n    const {corners, isTraversable} = hex\n    ctx.moveTo(0, 0)\n    ctx.beginPath()\n    corners.forEach(corner => {\n        ctx.lineTo(corner.x, corner.y)\n    })\n    ctx.lineTo(corners[0].x, corners[0].y)\n\n    ctx.lineWidth = 2\n    ctx.strokeStyle = '#3f3f3f'\n    ctx.stroke()\n\n\n    ctx.fillStyle = 'rgba(42, 160, 216, 0)'\n    if (isTraversable)\n        ctx.fillStyle = hex.color\n    ctx.fill()\n    ctx.closePath()\n\n    ctx.beginPath()\n    ctx.font = '12px sans-serif'\n    ctx.fillStyle = 'black'\n    ctx.fill()\n    ctx.fillText(hex.index, hex.screenCoords.x, hex.screenCoords.y)\n    ctx.closePath()\n}\n\nfunction drawHexIndexes(ctx, hex) {\n    const {corners} = hex\n    ctx.moveTo(0, 0)\n    ctx.beginPath()\n    corners.forEach(corner => {\n        ctx.lineTo(corner.x, corner.y)\n    })\n    ctx.lineTo(corners[0].x, corners[0].y)\n    ctx.fillStyle = 'transparent'\n    ctx.fill()\n    ctx.closePath()\n\n    ctx.beginPath()\n    ctx.font = '12px sans-serif'\n    ctx.fillStyle = 'black'\n    ctx.fill()\n    ctx.fillText(hex.index, hex.screenCoords.x, hex.screenCoords.y)\n    ctx.closePath()\n}\n\nexport default function Map(ctx, map) {\n    map.forEach(hex => {\n        drawHexagon(ctx, hex)\n    })\n}","import {drawCircle} from \"../lib/canvasUtilites.js\";\n\nexport default function Enemy(ctx, location) {\n    drawCircle(ctx, location.x, location.y, 'red')\n}","import {drawCircle} from \"../lib/canvasUtilites.js\";\n\nexport default function Player(ctx, location) {\n    drawCircle(ctx, location.x, location.y, 'cyan')\n}"],"names":["module","exports","Heap","parcelRequire","Node","Grid","Util","DiagonalMovement","Heuristic","AStarFinder","BestFirstFinder","BreadthFirstFinder","DijkstraFinder","BiAStarFinder","BiBestFirstFinder","BiBreadthFirstFinder","BiDijkstraFinder","IDAStarFinder","JumpPointFinder","Heap1","defaultCmp","floor","heapify","heappop","heappush","heappushpop","heapreplace","insort","min","nlargest","nsmallest","updateItem","_siftdown","_siftup","Math","x","y","a","lo","hi","cmp","mid","Error","length","splice","apply","concat","array","item","push","lastelt","returnitem","pop","_ref","i","_i","_len","_ref1","_results","_results1","_j","this","reverse","pos","indexOf","n","elem","result","slice","sort","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","replace","pushpop","prototype","peek","contains","clear","empty","size","clone","heap","toArray","insert","top","front","has","copy","window","call","$7zzf9","$a42148ccfac27a65$var$Grid","width_or_matrix","height","matrix","width","_buildNodes","j","Array","undefined","walkable","getNodeAt","isWalkableAt","isInside","setWalkableAt","Always","Never","IfAtMostOneObstacle","OnlyWhenNoObstacles","$329a8e0c63696565$export$8517a70715aa147e","$329a8e0c63696565$export$c4b91b67e703b905","$329a8e0c63696565$export$2d949ea0af312bcc","$329a8e0c63696565$export$89e29e4ab65e70a9","$329a8e0c63696565$export$5e02e614c519b9e9","$329a8e0c63696565$export$d30467eb49766dd9","$329a8e0c63696565$export$39c0513046ff5255","$329a8e0c63696565$var$backtrace","node","path","$329a8e0c63696565$var$interpolate","x0","y0","x1","y1","sx","sy","dx","dy","err","e2","abs","line","nodeA","nodeB","pathA","pathB","b","sum","sqrt","coord0","coord1","interpolated","interpolatedLen","expanded","len","grid","newPath","coord","testCoord","blocked","lastValidCoord","lx","ly","ldx","ldy","sq","compressed","px","py","$hzzug","$1aac84337125b69b$var$AStarFinder","opt","allowDiagonal","dontCrossCorners","heuristic","$li1KK","manhattan","weight","diagonalMovement","$l45mg","octile","findPath","startX","startY","endX","endY","neighbors","neighbor","l","ng","openList","f","endNode","SQRT2","g","startNode","opened","$4lmtk","backtrace","getNeighbors","closed","$2hZ2q","$6e9b6ee045d547f8$var$BreadthFirstFinder","shift","$f17d683e44782f49$var$BiAStarFinder","endOpenList","biBacktrace","h","startOpenList","$kJrAh","$5f670660ece60ec1$var$BiBreadthFirstFinder","by","$6c2f6242f59b8c44$var$IDAStarFinder","trackRecursion","timeLimit","Infinity","Date","getTime","search","cutoff","route","depth","startTime","t","k","neighbour","end","neighbours","$d8PM7","$b17f797e58859eb0$var$JPFNeverMoveDiagonally","constructor","_jump","trackJumpRecursion","tested","_findNeighbors","neighborNodes","neighborNode","max","$99142f314b22ebbe$var$JumpPointFinderBase","expandPath","_identifySuccessors","jumpPoint","jx","jy","d","jumpNode","$dd086e066465684f$var$JPFAlwaysMoveDiagonally","$fc480e495deb10e0$var$JPFMoveDiagonallyIfNoObstacles","isBottomWalkable","isNextWalkable","isTopWalkable","isLeftWalkable","isRightWalkable","$045dabed32de2ab6$var$JPFMoveDiagonallyIfAtMostOneObstacle","die","error","args","msg","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","Function","toString","objectCtorString","isArray","DRAFTABLE","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","prop","get","set","propOrOldValue","delete","add","is","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","descriptors","getOwnPropertyDescriptors","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","autoFreeze_","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","current","currentImpl","archType","hasChanges_","copyHelper","from","enableES5","proxyProperty","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","defineProperty","markChangesRecursively","object","hasSymbol","Symbol","hasProxies","Reflect","for","$d286d705bbfd559a$var$G","iterator","getOwnPropertySymbols","getOwnPropertyNames","_desc$get","currentState","deleteProperty","owner","setPrototypeOf","fn","arguments","Immer","$d286d705bbfd559a$export$22e8af3f75a010e3","config","produce","recipe","defaultBase","self","_this","_this2","hasError","Promise","then","p","ip","arg1","arg2","produceWithPatches","patches","inversePatches","nextState","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","bind","$f329557dcab6d0bb$export$2e2bcd8739ae039","$983350b7b3960a26$var$ownKeys","symbols","filter","sym","$983350b7b3960a26$export$2e2bcd8739ae039","defineProperties","$ad4393542232627c$var$formatProdErrorMessage","code","$ad4393542232627c$var$$$observable","observable","$ad4393542232627c$var$randomString","random","substring","split","$ad4393542232627c$export$4219e499db7ca678","INIT","REPLACE","PROBE_UNKNOWN_ACTION","$ad4393542232627c$var$isPlainObject","$ad4393542232627c$export$f51a9068ac82ea43","reducer","preloadedState","enhancer","_ref2","currentReducer","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","getState","subscribe","listener","isSubscribed","dispatch","action","type","listeners","replaceReducer","nextReducer","outerSubscribe","observer","observeState","next","unsubscribe","$ad4393542232627c$export$66e4520cdb265d18","reducers","reducerKeys","finalReducers","shapeAssertionError","finalReducerKeys","$ad4393542232627c$var$assertReducerShape","e","hasChanged","_key","previousStateForKey","nextStateForKey","$ad4393542232627c$export$f672e0b6f7222cd7","funcs","arg","reduce","$ad4393542232627c$export$9ff26e0402cc7b7","middlewares","store","_dispatch","middlewareAPI","chain","middleware","$ac5d5956ce0b399b$var$createThunkMiddleware","extraArgument","$ac5d5956ce0b399b$var$thunk","$74cf642ba7fa99c2$var$composeWithDevTools","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","__REDUX_DEVTOOLS_EXTENSION__","$74cf642ba7fa99c2$export$53b83ca8eaab0383","baseProto","$74cf642ba7fa99c2$export$20df1e9bd1a54f25","_super","$74cf642ba7fa99c2$var$__extends","species","arr","prepend","$74cf642ba7fa99c2$var$__spreadArray","$74cf642ba7fa99c2$var$curryGetDefaultMiddleware","options","_c","thunk","middlewareArray","immutableCheck","serializableCheck","$ac5d5956ce0b399b$export$2e2bcd8739ae039","withExtraArgument","$74cf642ba7fa99c2$export$36c1185aeee5b0a6","$74cf642ba7fa99c2$export$7d8a5b498da695ac","rootReducer","curriedGetDefaultMiddleware","_d","_e","_f","devTools","_g","_h","enhancers","finalMiddleware","middlewareEnhancer","finalCompose","$74cf642ba7fa99c2$var$__spreadValues","trace","storeEnhancers","$74cf642ba7fa99c2$export$309c7a02b0b0bc62","prepareAction","actionCreator","prepared","payload","meta","match","$74cf642ba7fa99c2$var$executeReducerBuilderCallback","builderCallback","defaultCaseReducer","actionsMap","actionMatchers","builder","addCase","typeOrActionCreator","addMatcher","matcher","addDefaultCase","$74cf642ba7fa99c2$export$4d8d9bd83c24ae8b","name","_reducer","initialState","$d286d705bbfd559a$export$2e2bcd8739ae039","reducerNames","sliceCaseReducersByName","sliceCaseReducersByType","actionCreators","buildReducer","extraReducers","finalCaseReducers","mapOrBuilderCallback","getInitialState","_c2","finalActionMatchers","finalDefaultCaseReducer","frozenInitialState_1","caseReducers","cr","previousState","caseReducer","$d286d705bbfd559a$export$541ac630993a4c84","$d286d705bbfd559a$export$16e3aed3edb85946","$74cf642ba7fa99c2$export$473eb76d322d0290","reducerName","prepareCallback","maybeReducerWithPrepare","prepare","actions","assign","$74cf642ba7fa99c2$var$alm","$d286d705bbfd559a$export$56771cf63ee491f5","definition","$348288c77228119c$exports","define","amd","astar","Graph","pathTo","curr","unshift","graph","start","cleanDirty","heuristics","closest","openHeap","BinaryHeap","closestNode","currentNode","il","isWall","gScore","getCost","beenVisited","visited","markDirty","rescoreElement","pos0","pos1","diagonal","D2","d1","d2","cleanNode","gridIn","row","GridNode","init","scoreFunction","content","dirtyNodes","ret","rowDebug","graphString","fromNeighbor","element","sinkDown","bubbleUp","remove","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","$d35cb3264cc8288b$exports","val","loadDefaults","defaults","q","r","data","rotateRight","times","_center","center","TypeError","rotateLeft","toJSON","radius","totalLength","ring","static","feed","q1","r1","q2","r2","q3","r3","q4","r4","q5","r5","hex","$86df5f3648707bb6$exports","Hex","$0e643b338a9dbd1a$exports","default","Direction","$a8f0932009eadd82$exports","list","North","NorthEast","SouthEast","South","SouthWest","NorthWest","all","CubeCoordinates","$b73bb3f281449773$var$CubeCoordinates","$b73bb3f281449773$exports","translated","direction","coord2","parse","str","spl","distance","hexes","merge","grids","thisHexes","otherHexes","values","directions","hex1","hex2","destCoord","addPath","last","minDist","toExpand","allPaths","minDistance","Number","POSITIVE_INFINITY","readyNextIteration","toExpandNext","easyPath","currentHex","recalibrate","$91ee2d479456fefa$exports","axis","types","factory","offsetFromZero","offset","signedModulo","dividend","divisor","compassToNumberDirection","orientation","test","toLowerCase","toUpperCase","includes","pointy","E","SE","SW","W","NW","NE","flat","S","N","ensureXY","isNumber","DIRECTION_COORDINATES","DIAGONAL_DIRECTION_COORDINATES","EPSILON","keyOrPoint","setFactory","isValidHex","newHex","hexesBetween","firstHex","lastHex","step","nudge","lerp","round","hexesInRangeFactory","centerHex","range","includeCenterHex","cubeToCartesian","equals","Boolean","neighborsOfFactory","coordinates","isString","pointWidth","mostLeft","mostRight","isPointy","toPoint","pointHeight","mostUp","mostDown","pointToHexFactory","pointOrX","fromPoint","parallelogramFactory","onCreate","firstCoordinate","secondCoordinate","thirdCoordinate","first","second","u","triangleFactory","DIRECTIONS","rStart","rEnd","hexagonFactory","startR","endR","rectangleFactory","firstStop","secondStop","secondOffset","ringFactory","spiralFactory","addFactory","Point","subtractFactory","multiplyFactory","divideFactory","PointFactory","methods","subtract","multiply","divide","isObject","__isHoneycombHex","fill","point","fromIndex","lastIndexOf","super","deleteCount","cube","isFlat","xRadius","yRadius","cornersFactory","origin","centerFactory","toPointFactory","fromPointFactory","equalsFactory","roundFactory","roundedQ","roundedR","roundedS","diffQ","diffR","diffS","lerpFactory","nudgeFactory","staticMethods","extendHex","normalizeRadiuses","cartesianToCube","defaultPrototype","cartesian","corners","toCartesian","toCube","finalPrototype","xOrProps","customProps","rest","isNaN","$d794670cd92ee24f$var$round","$d794670cd92ee24f$var$abs","$d794670cd92ee24f$var$random","$d794670cd92ee24f$export$8bf7aba4a9e09055","console","$d794670cd92ee24f$export$9cb4719e2e525b7a","objA","objB","ok","typeOfObjA","every","$d794670cd92ee24f$export$82aaec17d773afb5","qq","rr","ss","qDiff","rDiff","sDiff","$d794670cd92ee24f$export$8d933bb90701db02","$d794670cd92ee24f$export$3dc07afe418952bc","elements","head","tail","enqueue","dequeue","isEmpty","PI","$29ac11e92cfed9c3$var$PI","$29ac11e92cfed9c3$var$sqrt","$29ac11e92cfed9c3$var$abs","cos","$29ac11e92cfed9c3$var$cos","sin","$29ac11e92cfed9c3$var$sin","$29ac11e92cfed9c3$var$max","$29ac11e92cfed9c3$var$round","$29ac11e92cfed9c3$export$7423c88bc54edb74","f0","f1","f2","f3","b0","b1","b2","b3","startAngle","$29ac11e92cfed9c3$export$4aabe0d20c9c03b3","upLeft","$29ac11e92cfed9c3$export$578abc0d25ff055c","up","upRight","downLeft","down","downRight","$29ac11e92cfed9c3$export$78ca07932ec5b059","$29ac11e92cfed9c3$export$105684a3041cb6f3","$29ac11e92cfed9c3$export$1f629b726c596d83","hexA","hexB","$29ac11e92cfed9c3$export$b63b5324e8982b07","$29ac11e92cfed9c3$export$6a6a19f7364179f1","$29ac11e92cfed9c3$export$9fddb9d0dd7d8a54","$29ac11e92cfed9c3$export$403bdadaaac718df","$29ac11e92cfed9c3$export$62de34ee58ac1d25","M","$29ac11e92cfed9c3$export$db6aa93980adec58","corner","angle","$29ac11e92cfed9c3$export$4fa5b8b5fe15b0c7","$cc33b8eb4e7cd882$var$min","$cc33b8eb4e7cd882$var$max","$cc33b8eb4e7cd882$export$3c17558da18e4d75","isTraversable","hexTile","cubeCoords","screenCoords","neighborIndexes","occupants","color","$cc33b8eb4e7cd882$export$a8309c23f2b47586","pixelPoint","pt","roundedHexCoords","$29ac11e92cfed9c3$export$7e5e21c3b78baf1a","$cc33b8eb4e7cd882$export$723aa6ff9f95b23e","hexMap","hexTileMap","numOfTiles","num","randHex","$cc33b8eb4e7cd882$export$20dd22160c74ac5d","$cc33b8eb4e7cd882$export$b01f4e4978391808","findIndex","nIndex","$f9e085fd2f1f1a35$var$gameSlice","$74cf642ba7fa99c2$exports","createSlice","player","tileIndex","location","health","power","credits","enemyTypes","grunt","drops","enemies","selectedHex","turns","setupGame","numOfEnemies","$cc33b8eb4e7cd882$export$9c2f2ade8085b855","playerTile","$f9e085fd2f1f1a35$var$indexOfTraversableTile","enemyTile","enemy","lastTileIndex","movePlayer","nearestTile","nearestHexTile","$cc33b8eb4e7cd882$export$a9cb0d5bfa9e1268","lastTurn","goal","cameFrom","frontier","$3443041a74cfe957$export$5a5c1dbd910e2c32","log","magicNum","tile","rando","$f9e085fd2f1f1a35$export$77de8d36f99a553b","$f9e085fd2f1f1a35$export$cbeacfcdc700e0d2","$f9e085fd2f1f1a35$export$2e2bcd8739ae039","$f8ebe52f73808a10$export$2e2bcd8739ae039","configureStore","game","$c9e71eccb3f83108$export$8daab6f91f7ff730","ctx","strokeWidth","beginPath","arc","fillStyle","lineWidth","strokeStyle","stroke","closePath","$35da740d59af89ba$var$root","document","getElementById","$35da740d59af89ba$var$ctx","getContext","$35da740d59af89ba$var$state","$35da740d59af89ba$var$x","$35da740d59af89ba$var$y","$35da740d59af89ba$var$render","innerWidth","innerHeight","translate","clearRect","playerLocation","moveTo","lineTo","font","fillText","$372c5c28e42dce4f$var$drawHexagon","$a888b613c9745759$export$2e2bcd8739ae039","$b463106ba633310d$export$2e2bcd8739ae039","cancelAnimationFrame","addEventListener","event","rect","canvas","getBoundingClientRect","clientX","left","clientY","invMat","getTransform","invertSelf","c","$c9e71eccb3f83108$export$8b59d3c9ad87edcd"],"version":3,"file":"index.e4812222.js.map"}